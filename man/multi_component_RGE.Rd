% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/order_cells.R
\name{multi_component_RGE}
\alias{multi_component_RGE}
\title{#' the following functioin is used to learn trajectory on each disjointed components 
#' @param cds CellDataSet  The CellDataSet upon which to perform this operation
#' @param scale A logical argument to determine whether or not we should scale the data before constructing trajectory (default to be FALSE)
#' @param RGE_method The method for reversed graph embedding  
#' @param partition_group The column name in the pData used to partition cells 
#' @param irlba_pca_res The matrix for PCA top components (retrieved with irlba by default)
#' @param max_components Number of maximum component 
#' @param extra_arguments Extra arguments passed into learnGraph (which calls this function) 
#' @param close_loop A logical argument to determine whether or not we should close loop for the trajectory we learned (default to be FALSE)
#' @param verbose Whether to emit verbose output when running this function 
multi_tree_DDRTree <- function(cds, scale = FALSE, RGE_method, partition_group = 'louvain_component', irlba_pca_res, max_components, extra_arguments, close_loop = FALSE, verbose = FALSE) {
  louvain_component <- pData(cds)[, partition_group]
  
  X <- t(irlba_pca_res)
  
  reducedDimK_coord <- NULL  
  dp_mst <- NULL 
  pr_graph_cell_proj_closest_vertex <- NULL 
  cell_name_vec <- NULL
  
  for(cur_comp in unique(louvain_component)) {
    X_subset <- X[, louvain_component == cur_comp]
    
    #add other parameters...
    if(scale) 
      X_subset <- t(as.matrix(scale(t(X_subset))))
    
    ncenter <- cal_ncenter(ncol(X_subset))
    
    ddr_args <- c(list(X=X_subset, dimensions=max_components, ncenter=ncenter, no_reduction = T, verbose = verbose),
                  extra_arguments[names(extra_arguments) %in% c("initial_method", "maxIter", "sigma", "lambda", "param.gamma", "tol")])
    #browser()
    ddrtree_res <- do.call(DDRTree, ddr_args)
    
    if(is.null(reducedDimK_coord)) {
      curr_cell_names <- paste("Y_", 1:ncol(ddrtree_res$Y), sep = "")
      pr_graph_cell_proj_closest_vertex <- matrix(apply(ddrtree_res$R, 1, which.max))
      cell_name_vec <- colnames(X_subset)
    } else {
      curr_cell_names <- paste("Y_", ncol(reducedDimK_coord) + 1:ncol(ddrtree_res$Y), sep = "")
      pr_graph_cell_proj_closest_vertex <- rbind(pr_graph_cell_proj_closest_vertex, matrix(apply(ddrtree_res$R, 1, which.max) + ncol(reducedDimK_coord)))
      cell_name_vec <- c(cell_name_vec, colnames(X_subset))
    }
    
    curr_reducedDimK_coord <- ddrtree_res$Y
    
    dp <- as.matrix(dist(t(curr_reducedDimK_coord))) #ddrtree_res$stree[1:ncol(ddrtree_res$Y), 1:ncol(ddrtree_res$Y)]
    dimnames(dp) <- list(curr_cell_names, curr_cell_names)
    
    cur_dp_mst <- mst(graph.adjacency(dp, mode = "undirected", weighted = TRUE))
    
    tmp <- matrix(apply(ddrtree_res$R, 1, which.max))
    
    if(length(close_loop) == length(unique(louvain_component)))
      curr_close_loop <- close_loop[which(unique(louvain_component) %in% cur_comp)]
    else 
      curr_close_loop <- close_loop[1]
    
    if(curr_close_loop == TRUE) {
      colnames(curr_reducedDimK_coord) <- curr_cell_names
      connectTips_res <- connectTips(pData(cds)[louvain_component == cur_comp, ], ddrtree_res$R, cur_dp_mst, 
                                     curr_reducedDimK_coord, cds@reducedDimS[, louvain_component == cur_comp])
      
      curr_reducedDimK_coord <- connectTips_res$reducedDimK_df
      cur_dp_mst <- connectTips_res$mst_g
      
      current_W <- as.matrix(get.adjacency(cur_dp_mst))
      message('current_W dim is ', nrow(current_W), ncol(current_W))
      l1graph_args <- c(list(X = curr_reducedDimK_coord, C0 = curr_reducedDimK_coord, G = current_W, gstruct = 'l1-graph', verbose = verbose),
                        extra_arguments[names(extra_arguments) %in% c('maxiter', 'eps', 'L1.lambda', 'L1.gamma', 'L1.sigma', 'nn')])
      
      l1_graph_res <- do.call(principal_graph, l1graph_args)
      
      W <- l1_graph_res$W
      message('W dim is ', nrow(W), ncol(W))
      message('nrow(ddrtree_res$R) is ', nrow(ddrtree_res$R))
      start_id <- min(nrow(ddrtree_res$R), nrow(current_W))
      
      dimnames(W) <- list(V(cur_dp_mst)$name, V(cur_dp_mst)$name)
      current_W[, start_id:nrow(current_W)] <- W[, start_id:nrow(current_W)]
      current_W[start_id:nrow(current_W), ] <- W[start_id:nrow(current_W), ]
      
      # W[W < 1e-5] <- 0
      cur_dp_mst <- graph.adjacency(current_W, mode = "undirected", weighted = TRUE)
    }
    
    dp_mst <- graph.union(dp_mst, cur_dp_mst)
    reducedDimK_coord <- cbind(reducedDimK_coord, curr_reducedDimK_coord)
    
  }
  
  row.names(pr_graph_cell_proj_closest_vertex) <- cell_name_vec
  
  ddrtree_res_W <- ddrtree_res$W
  ddrtree_res_Z <- cds@reducedDimS
  ddrtree_res_Y <- reducedDimK_coord
  
  cds@auxOrderingData[[RGE_method]] <- ddrtree_res[c('stree', 'Q', 'R', 'objective_vals', 'history')]
  cds@auxOrderingData[[RGE_method]]$pr_graph_cell_proj_closest_vertex <- pr_graph_cell_proj_closest_vertex
  
  colnames(ddrtree_res_Y) <- paste0("Y_", 1:ncol(ddrtree_res_Y), sep = "")
  
  return(list(cds = cds, 
              ddrtree_res_W = ddrtree_res_W, 
              ddrtree_res_Z = ddrtree_res_Z, 
              ddrtree_res_Y = ddrtree_res_Y, 
              dp_mst = dp_mst))
}}
\usage{
multi_component_RGE(cds, scale = FALSE, RGE_method,
  partition_group = "louvain_component", irlba_pca_res, max_components,
  extra_arguments, close_loop = FALSE, euclidean_distance_ratio = 1,
  geodestic_distance_ratio = 1/3, verbose = FALSE)
}
\description{
#' the following functioin is used to learn trajectory on each disjointed components 
#' @param cds CellDataSet  The CellDataSet upon which to perform this operation
#' @param scale A logical argument to determine whether or not we should scale the data before constructing trajectory (default to be FALSE)
#' @param RGE_method The method for reversed graph embedding  
#' @param partition_group The column name in the pData used to partition cells 
#' @param irlba_pca_res The matrix for PCA top components (retrieved with irlba by default)
#' @param max_components Number of maximum component 
#' @param extra_arguments Extra arguments passed into learnGraph (which calls this function) 
#' @param close_loop A logical argument to determine whether or not we should close loop for the trajectory we learned (default to be FALSE)
#' @param verbose Whether to emit verbose output when running this function 
multi_tree_DDRTree <- function(cds, scale = FALSE, RGE_method, partition_group = 'louvain_component', irlba_pca_res, max_components, extra_arguments, close_loop = FALSE, verbose = FALSE) {
  louvain_component <- pData(cds)[, partition_group]
  
  X <- t(irlba_pca_res)
  
  reducedDimK_coord <- NULL  
  dp_mst <- NULL 
  pr_graph_cell_proj_closest_vertex <- NULL 
  cell_name_vec <- NULL
  
  for(cur_comp in unique(louvain_component)) {
    X_subset <- X[, louvain_component == cur_comp]
    
    #add other parameters...
    if(scale) 
      X_subset <- t(as.matrix(scale(t(X_subset))))
    
    ncenter <- cal_ncenter(ncol(X_subset))
    
    ddr_args <- c(list(X=X_subset, dimensions=max_components, ncenter=ncenter, no_reduction = T, verbose = verbose),
                  extra_arguments[names(extra_arguments) %in% c("initial_method", "maxIter", "sigma", "lambda", "param.gamma", "tol")])
    #browser()
    ddrtree_res <- do.call(DDRTree, ddr_args)
    
    if(is.null(reducedDimK_coord)) {
      curr_cell_names <- paste("Y_", 1:ncol(ddrtree_res$Y), sep = "")
      pr_graph_cell_proj_closest_vertex <- matrix(apply(ddrtree_res$R, 1, which.max))
      cell_name_vec <- colnames(X_subset)
    } else {
      curr_cell_names <- paste("Y_", ncol(reducedDimK_coord) + 1:ncol(ddrtree_res$Y), sep = "")
      pr_graph_cell_proj_closest_vertex <- rbind(pr_graph_cell_proj_closest_vertex, matrix(apply(ddrtree_res$R, 1, which.max) + ncol(reducedDimK_coord)))
      cell_name_vec <- c(cell_name_vec, colnames(X_subset))
    }
    
    curr_reducedDimK_coord <- ddrtree_res$Y
    
    dp <- as.matrix(dist(t(curr_reducedDimK_coord))) #ddrtree_res$stree[1:ncol(ddrtree_res$Y), 1:ncol(ddrtree_res$Y)]
    dimnames(dp) <- list(curr_cell_names, curr_cell_names)
    
    cur_dp_mst <- mst(graph.adjacency(dp, mode = "undirected", weighted = TRUE))
    
    tmp <- matrix(apply(ddrtree_res$R, 1, which.max))
    
    if(length(close_loop) == length(unique(louvain_component)))
      curr_close_loop <- close_loop[which(unique(louvain_component) %in% cur_comp)]
    else 
      curr_close_loop <- close_loop[1]
    
    if(curr_close_loop == TRUE) {
      colnames(curr_reducedDimK_coord) <- curr_cell_names
      connectTips_res <- connectTips(pData(cds)[louvain_component == cur_comp, ], ddrtree_res$R, cur_dp_mst, 
                                     curr_reducedDimK_coord, cds@reducedDimS[, louvain_component == cur_comp])
      
      curr_reducedDimK_coord <- connectTips_res$reducedDimK_df
      cur_dp_mst <- connectTips_res$mst_g
      
      current_W <- as.matrix(get.adjacency(cur_dp_mst))
      message('current_W dim is ', nrow(current_W), ncol(current_W))
      l1graph_args <- c(list(X = curr_reducedDimK_coord, C0 = curr_reducedDimK_coord, G = current_W, gstruct = 'l1-graph', verbose = verbose),
                        extra_arguments[names(extra_arguments) %in% c('maxiter', 'eps', 'L1.lambda', 'L1.gamma', 'L1.sigma', 'nn')])
      
      l1_graph_res <- do.call(principal_graph, l1graph_args)
      
      W <- l1_graph_res$W
      message('W dim is ', nrow(W), ncol(W))
      message('nrow(ddrtree_res$R) is ', nrow(ddrtree_res$R))
      start_id <- min(nrow(ddrtree_res$R), nrow(current_W))
      
      dimnames(W) <- list(V(cur_dp_mst)$name, V(cur_dp_mst)$name)
      current_W[, start_id:nrow(current_W)] <- W[, start_id:nrow(current_W)]
      current_W[start_id:nrow(current_W), ] <- W[start_id:nrow(current_W), ]
      
      # W[W < 1e-5] <- 0
      cur_dp_mst <- graph.adjacency(current_W, mode = "undirected", weighted = TRUE)
    }
    
    dp_mst <- graph.union(dp_mst, cur_dp_mst)
    reducedDimK_coord <- cbind(reducedDimK_coord, curr_reducedDimK_coord)
    
  }
  
  row.names(pr_graph_cell_proj_closest_vertex) <- cell_name_vec
  
  ddrtree_res_W <- ddrtree_res$W
  ddrtree_res_Z <- cds@reducedDimS
  ddrtree_res_Y <- reducedDimK_coord
  
  cds@auxOrderingData[[RGE_method]] <- ddrtree_res[c('stree', 'Q', 'R', 'objective_vals', 'history')]
  cds@auxOrderingData[[RGE_method]]$pr_graph_cell_proj_closest_vertex <- pr_graph_cell_proj_closest_vertex
  
  colnames(ddrtree_res_Y) <- paste0("Y_", 1:ncol(ddrtree_res_Y), sep = "")
  
  return(list(cds = cds, 
              ddrtree_res_W = ddrtree_res_W, 
              ddrtree_res_Z = ddrtree_res_Z, 
              ddrtree_res_Y = ddrtree_res_Y, 
              dp_mst = dp_mst))
}
}
