---
layout: vanilla
permalink: /docs/
description: "Documentation for Monocle."
modified: 2013-09-11
tags: [monocle, manual, vignette]
---
<!DOCTYPE html>
<html lang="{{ page.lang | default: site.lang | default: "en" }}">

  {% include head.html %}

  <!-- See here for how to use the TOC control:
  https://afeld.github.io/bootstrap-toc/ -->
  <body  data-spy="scroll" data-target="#toc">
    {% include header.html %}

    <div class="container">
      <div class="row">
        <!-- sidebar, which will move to the top on a small screen -->
        <div class="col-sm-4">
          <nav id="toc" data-spy="affix" data-toggle="toc"></nav>
        </div>
        <!-- main content area -->
        <div class="col-sm-8">

<h2> Abstract </h2>
Single cell gene expression studies enable profiling of transcriptional regulation during complex biological processes and within highly hetergeneous cell populations. These studies allow discovery of genes that identify certain subtypes of cells, or that mark a particular intermediate states during a biological process. In many single cell studies, individual cells are executing through a gene expression program in an unsynchronized manner. In effect, each cell is a snapshot of the transcriptional program under study. The package <strong>Monocle</strong> provides tools for analyzing single-cell expression experiments. Monocle introduced the strategy of ordering single cells in <strong>pseudotime</strong>, placing them along a trajectory corresponding to a biological process such as cell differentiation. Monocle learns this trajectory directly from the data, in either a fully unsupervised or a semi-supervised manner. It also performs differential gene expression and clustering to identify important genes and cell states. It is designed for RNA-Seq studies, but can be used with other assays. For more information on the algorithm at the core of <strong>monocle</strong>, or to learn more about how to use single cell RNA-Seq to study a complex biological process, see Cole Trapnell and Davide Cacchiarelli et al (2014): The dynamics and regulators of cell fate decisions are revealed
by pseudo-temporal ordering of single cells. Nature Biotechnology

{% highlight R %}
library(HSMMSingleCell)
library(monocle)
data(HSMM_expr_matrix)
data(HSMM_gene_annotation)
data(HSMM_sample_sheet)
{% endhighlight %}

<h2>Introduction </h2>


The monocle package provides a toolkit for analyzing single cell gene expression experiments. This vignette provides an overview of a single cell RNA-Seq analysis workflow with Monocle. Monocle was originally developed to analyze dynamic biological processes such as cell differentiation, although it also supports simpler experimental settings.

<strong>Monocle 2</strong> includes new, improved algorithms for classifying and counting cells, performing differential expression analysis between subpopulations of cells, and reconstructing cellular trajectories. Monocle 2 has also been re-engineered to work well with very large single-cell RNA-Seq experiments containing tens of thousands of cells or even more.
<br>
Monocle can help you perform three main types of analysis:

<ul>
 <li><strong>Clustering, classifying, and counting cells.</strong> Single-cell RNA-Seq experiments allow you to discover new (and possibly rare) subtypes of cells. Monocle helps you identify them.
 <li><strong>Constructing single-cell trajectories.</strong> In development, disease, and throughout life, cells transition from one state to another. Monocle helps you discover these transitions.
 <li> <strong>Differential expression analysis.</strong> Characterizing new cell types and states begins with comparing them to other, better understood cells. Monocle includes a sophisticated but easy to use system for differential expression.
</ul>

Before we look at Monocle's functions for each of these common analysis tasks, let's see how to load up single-cell datasets in Monocle.


<h2> Getting started</h2>

Monocle takes a matrix of gene expression values as calculated by Cufflinks or another gene expression estimation program. Monocle can work with relative expression values (e.g. FPKM or TPM units) or absolute transcript counts (e.g. from UMI experiments). Monocle also works "out-of-the-box" with the transcript count matrices produced by <a href="https://support.10xgenomics.com/single-cell/software/overview/welcome">CellRanger</a>, the software pipeline for analyzing experiments from the 10X Genomics Chromium instrument. Monocle also works well with data from other RNA-Seq workflows such as <a href="http://biorxiv.org/content/early/2017/02/02/104844">sci-RNA-Seq</a> and instruments like the Biorad ddSEQ. Although Monocle can be used with raw read counts, these are not directly proportional to expression values unless you normalize them by length, so some Monocle functions could produce nonsense results. If you don't have UMI counts, We recommend you load up FPKM or TPM values instead of raw read counts.

<h3>The CellDataSet class</h3>

Monocle holds single cell expression data in objects of the <code>CellDataSet</code> class. The class is derived from the Bioconductor <code>ExpressionSet</code> class, which provides a common interface familiar to those who have analyzed microarray experiments with Bioconductor. The class requires three input files:
<ul>
  <li> <code>exprs</code>, a numeric matrix of expression values, where rows are genes, and columns are cells
  <li> <code>phenoData</code>, an <code>AnnotatedDataFrame</code> object, where rows are cells, and columns are cell attributes (such as cell type, culture condition, day captured, etc.)
  <li> <code>featureData</code>, an <code>AnnotatedDataFrame</code> object, where rows are features (e.g. genes), and columns are gene attributes, such as biotype, gc content, etc.
</ul>

<div class="panel panel-warning">
  <div class="panel-heading">
    <h3 class="panel-title">Required dimensions for input files</h3>
  </div>
  <div class="panel-body">
    The expression value matrix <strong>must</strong>:
    <ul>
    <li>have the same number of columns as the <code>phenoData</code> has rows.
    <li>have the same number of rows as the <code>featureData</code> data frame has rows.
    </ul>
    Additionally:
    <ul>
    <li>row names of the <code>phenoData</code> object should match the column names of the expression matrix.
    <li>row names of the <code>featureData</code> object should match row names of the expression matrix.
    <li> one of the columns of the <code>featureData</code> should be named "gene_short_name".
    </ul>

  </div>
</div>

You can create a new <code>CellDataSet</code> object as follows:

{% highlight R %}
#do not run
HSMM_expr_matrix <- read.table("fpkm_matrix.txt")
HSMM_sample_sheet <- read.delim("cell_sample_sheet.txt")
HSMM_gene_annotation <- read.delim("gene_annotations.txt")
{% endhighlight %}

Once these tables are loaded, you can create the CellDataSet object like this:

{% highlight R %}
pd <- new("AnnotatedDataFrame", data = HSMM_sample_sheet)
fd <- new("AnnotatedDataFrame", data = HSMM_gene_annotation)
HSMM <- newCellDataSet(as.matrix(HSMM_expr_matrix), phenoData = pd, featureData = fd)
{% endhighlight %}
<br>
SKIPPING SOME STUFF

This will create a CellDataSet object with expression values measured in FPKM, a measure of relative expression reported by Cufflinks.
By default, Monocle assumes that your expression data is in units of transcript counts and uses a negative binomial model to test for differential expression in downstream steps.
However, if you're using relative expression values such as TPM or FPKM data, see below for how to tell Monocle how to model it in downstream steps.

<br>
<br>

<strong>NOTE:</strong> if you do have UMI data, you should <i>not</i> normalize it yourself prior to creating your <code>CellDataSet</code>.
You should also <i>not</i> try to convert the UMI counts to relative abundances (by converting it to FPKM/TPM data).
You should <i>not</i> use <code>relative2abs()</code> as discussed below in section 3.4. Monocle will do all needed normalization steps internally.
Normalizing it yourself risks breaking some of Monocle's key steps.

<br>
<br>

<h3> Choosing a Distribution for Expression Data </h3>

Monocle works well with both relative expression data and count-based measures (e.g. UMIs).
In general, it works best with transcript count data, especially UMI data.
Whatever your data type, it is <i>critical</i> that specify the appropriate distribution for it.
FPKM/TPM values are generally log-normally distributed, while UMIs or read counts are better modeled with the negative binomial.
To work with count data, specify the negative binomial distribution as the <code>expressionFamily</code> argument to <code>newCellDataSet</code>:

{% highlight R %}
#Do not run
HSMM <- newCellDataSet(count_matrix,
                        phenoData = pd,
                        featureData = fd,
                        expressionFamily=negbinomial.size())
{% endhighlight %}

 There are several allowed values for <code>expressionFamily</code>, which expects a "family function" from the VGAM package:

 <table class="table">
   <thead>
     <tr>
       <th>Family function</th>
       <th>Data type</th>
       <th>Notes</th>
     </tr>
   </thead>
   <tbody>
     <tr>
       <td><code>negbinomial.size()</code></td>
       <td>UMIs, Transcript counts from experiments with spike-ins or \Rfunction{relative2abs}, raw read counts</td>
       <td>Negative binomial distribution with fixed variance (which is automatically calculated by Monocle). Recommended for most users.</td>
     </tr>
     <tr>
       <td><code>negbinomial()</code></td>
       <td>UMIs, Transcript counts from experiments with spike-ins or \Rfunction{relative2abs}, raw read counts</td>
       <td>Slightly more accurate than \Rfunction{negbinomial.size()}, but much, much slower. Not recommended except for very small datasets.</td>
     </tr>
     <tr>
       <td><code>tobit()</code></td>
       <td>FPKM, TPM</td>
       <td>Tobits are truncated normal distributions. Using \Rfunction{tobit()} will tell Monocle to log-transform your data where appropriate. Do not transform it yourself.</td>
     </tr>
     <tr>
       <td><code>gaussianff()M</code></td>
       <td>log-transformed FPKM/TPMs, Ct values from single-cell qPCR</td>
       <td>If you want to use Monocle on data you have already transformed to be normally distributed, you can use this function, though some Monocle features may not work well.</td>
     </tr>
   </tbody>
 </table>

 <strong>Using the wrong expressionFamily for your data will lead to bad results</strong>, errors from Monocle, or both.
 However, if you have FPKM/TPM data, you can still use negative binomial if you first convert your relative expression values to transcript counts using <code>relative2abs()</code>.
 This often leads to much more accurate results than using <code>tobit()</code>. See section 3.4 for details.

 <br>
 <br>

 <h3> Working with Large Data Sets </h3>

 Some single-cell RNA-Seq experiments report measurements from tens of thousands of cells or more.
 As instrumentation improves and costs drop, experiments will become ever larger and more complex, with many conditions, controls, and replicates.
 A matrix of expression data with 50,000 cells and a measurement for each of the 25,000+ genes in the human genome can take up a lot of memory.
 However, because current protocols typically don't capture all or even most of the mRNA molecules in each cell, many of the entries of expression matrices are zero.
 Using <i>sparse matrices</i> can help you work with huge datasets on a typical computer.
 We generally recommend the use of sparseMatrices for most users, as it speeds up many computations even for more modestly sized datasets.
<br>
<br>
To work with your data in a sparse format, simply provide it to Monocle as a sparse matrix from the <i>Matrix</i> package:
<br>
<br>

{% highlight R %}
HSMM <- newCellDataSet(as(as.matrix(rpc_matrix), "sparseMatrix"),
                        phenoData = pd,
                        featureData = fd,
                        lowerDetectionLimit=0.5,
                        expressionFamily=negbinomial.size())
{% endhighlight %}

<br>
<br>

<strong>NOTE: </strong> The output from a number of RNA-Seq pipelines, including CellRanger, is already in a sparseMatrix format (e.g. MTX).
If so, you should just pass it directly to newCellDataSet without first converting it to a dense matrix (via <code>as.matrix()</code>, because that may exceed your available memeory.
If you have 10X Genomics data and are using <i>cellrangerRkit</i>, you can use it to load your data and then pass that to Monocle as follows:

<br>

{% highlight R %}

cellranger_pipestance_path <- "/path/to/your/pipeline/output/directory"
gbm <- load_cellranger_matrix(cellranger_pipestance_path)

gbm_cds <- newCellDataSet(exprs(gbm),
                          phenoData = pData(gbm),
                          featureData = fData(gbm),
                          lowerDetectionLimit=0.5,
                          expressionFamily=negbinomial.size())
{% endhighlight %}

<br>

Monocle's sparse matrix support is provided by the <i>Matrix</i> package.
Other sparse matrix packages, such as <i>slam</i> or <i>SparseM</i> are not supported.

<h3> 3.4 Converting Relative Expression Values into mRna Counts </h3>

If you performed your single-cell RNA-Seq experiment using <i>spike-in</i> standards, you can convert these measurements into mRNAs per cell (RPC).
RPC values are often easier to analyze than FPKM or TPM values, because have better statistical tools to model them.
In fact, it's possible to convert FPKM or TPM values to RPC values even if there were no spike-in standards included in the experiment.
Monocle 2 includes an algorithm called <i>Census</i> which performs this conversion (Qiu <i>et al</i>, submitted).
You can convert to RPC values before creating your CellDataSet object using the <code>relative2abs()</code> function, as follows:

<br>
<br>

{% highlight R %}
pd <- new("AnnotatedDataFrame", data = HSMM_sample_sheet)
 fd <- new("AnnotatedDataFrame", data = HSMM_gene_annotation)

 # First create a CellDataSet from the relative expression levels
 HSMM <- newCellDataSet(as.matrix(HSMM_expr_matrix),
                        phenoData = pd,
                        featureData = fd,
                        lowerDetectionLimit=0.1,
                        expressionFamily=tobit(Lower=0.1))

 # Next, use it to estimate RNA counts
 rpc_matrix <- relative2abs(HSMM, method = "num_genes")

 # Now, make a new CellDataSet using the RNA counts
 HSMM <- newCellDataSet(as(as.matrix(rpc_matrix), "sparseMatrix"),
                        phenoData = pd,
                        featureData = fd,
                        lowerDetectionLimit=0.5,
                        expressionFamily=negbinomial.size())
{% endhighlight %}

<br>
<br>

Note that since we are using RPC values, we have changed the value of <i>lowerDetectionLimit</i> to reflect the new scale of expression.
Importantly, we have also set the <i>expressionFamily</i> to <i>negbinomial()</i>, which tells Monocle to use the negative binomial distribution in certain downstream statistical tests.
Failing to change these two options can create problems later on, so make sure not to forget them when using RPC values.
<br>
<br>
Finally, we'll also call two functions that pre-calculate some information about the data.
Size factors help us normalize for differences in mRNA recovered across cells, and "dispersion" values will help us perform differential expression analysis later.
{% highlight R %}
HSMM <- estimateSizeFactors(HSMM)
HSMM <- estimateDispersions(HSMM)
{% endhighlight %}
<br>
<br>
We're now ready to start using the <i>HSMM</i> object in our analysis.
<br>
<br>

<h3> Filtering Low-Quality Cells </h3>
The first step in any single-cell RNA-Seq analysis is identifying poor-quality libraries from further analysis.
Most single-cell workflows will include at least some libraries made from dead cells or empty wells in a plate.
It's also crucial to remove doublets: libraries that were made from two or more cells accidentally.
These cells can disrupt downstream steps like pseudotime ordering or clustering.
This section walks through typical quality control steps that should be performed as part of all analyses with Monocle.
<br>
<br>
It is often convenient to know how many express a particular gene, or how many genes are expressed by a given cell.
Monocle provides a simple function to compute those statistics:

{% highlight R %}

HSMM <- detectGenes(HSMM, min_expr = 0.1)
print(head(fData(HSMM)))
expressed_genes <- row.names(subset(fData(HSMM), num_cells_expressed >= 10))

{% endhighlight %}
<br>
<br>

The vector <i>expressed_genes</i> now holds the identifiers for genes expressed in at least 50 cells of the data set.
We will use this list later when we put the cells in order of biological progress.
It is also sometimes convenient to exclude genes expressed in few if any cells from the <i>CellDataSet</i> object so as not to waste CPU time analyzing them for differential expression.
<br>
<br>
Let's start trying to remove unwanted, poor quality libraries from the CellDataSet.
Your single cell RNA-Seq protocol may have given you the opportunity to image individual cells after capture but prior to lysis.
This image data allows you to score your cells, confirming that none of your libraries were made from empty wells or wells with excess cell debris.
With some protocols and instruments, you may get more than one cell captured instead just a single cell.
You should exclude libraries that you believe did not come from a single cell, if possible.
Empty well or debris well libraries can be especially problematic for Monocle.
It's also a good idea to check that each cell's RNA-seq library was sequenced to an acceptible degree.
While there is no widely accepted minimum level for what constitutes seequencing "deeply enough", use your judgement: a cell sequenced with only a few thousand reads is unlikely to yield meaningful measurements.
<br>
<br>
<i>CellDataSet</i> objects provide a convenient place to store per-cell scoring data: the <i>phenoData</i> slot.
Simply include scoring attributes as columns in the data frome you used to create your <i>CellDataSet</i> container.
You can then easily filter out cells that don't pass quality control.
You might also filter cells based on metrics from high throughput sequencing quality assessment packages such as FastQC.
Such tools can often identify RNA-Seq libraries made from heavily degraded RNA, or where the library contains an abnormally large amount of ribosomal, mitochondrial, or other RNA type that you might not be interested in.
<br>
<br>
 The HSMM dataset included with this package has scoring columns built in:
<br>

{% highlight R %}
print(head(pData(HSMM)))
{% endhighlight %}

This dataset has already been filtered using the following commands:

{% highlight R %}
valid_cells <- row.names(subset(pData(HSMM), Cells.in.Well == 1 & Control == FALSE & Clump == FALSE & Debris == FALSE & Mapped.Fragments > 1000000))
 HSMM <- HSMM[,valid_cells]
{% endhighlight %}

<br>
<br>

If you are using RPC values to measure expresion, as we are in this vignette, it's also good to look at the distribution of mRNA totals across the cells:

{% highlight R %}
pData(HSMM)$Total_mRNAs <- Matrix::colSums(exprs(HSMM))


HSMM <- HSMM[,pData(HSMM)$Total_mRNAs < 1e6]
upper_bound <- 10^(mean(log10(pData(HSMM)$Total_mRNAs)) + 2*sd(log10(pData(HSMM)$Total_mRNAs)))
lower_bound <- 10^(mean(log10(pData(HSMM)$Total_mRNAs)) - 2*sd(log10(pData(HSMM)$Total_mRNAs)))
 qplot(Total_mRNAs, data=pData(HSMM), color=Hours, geom="density") +
   geom_vline(xintercept=lower_bound) +
   geom_vline(xintercept=upper_bound)

HSMM <- HSMM[,pData(HSMM)$Total_mRNAs > lower_bound &
              pData(HSMM)$Total_mRNAs < upper_bound]
HSMM <- detectGenes(HSMM, min_expr = 0.1)
{% endhighlight %}

<br>
<br>

We've gone ahead and removed the few cells with either very low mRNA recovery or far more mRNA that the typical cell. Often, doublets or triplets have roughly twice the mRNA recovered as true single cells, so the latter filter is another means of excluding all but single cells from the analysis. Such filtering is handy if your protocol doesn't allow directly visualization of cell after they've been captured. Note that these thresholds of 10,000 and 40,000 mRNAs are specific to this dataset. You may need to adjust filter thresholds based on your experimental protocol.

Once you've excluded cells that do not pass your quality control filters, you should verify that the expression values stored in your <i>CellDataSet</i> follow a distribution that is roughly lognormal:

{% highlight R %}
 # Log-transform each value in the expression matrix.
 L <- log(exprs(HSMM[expressed_genes,]))

 # Standardize each gene, so that they are all on the same scale,
 # Then melt the data with plyr so we can plot it easily"
 melted_dens_df <- melt(Matrix::t(scale(Matrix::t(L))))

 # Plot the distribution of the standardized gene expression values.
 qplot(value, geom="density", data=melted_dens_df) +
   stat_function(fun = dnorm, size=0.5, color='red') +
   xlab("Standardized log(FPKM)") +
   ylab("Density")
{% endhighlight %}

<div class="text-center">
  <img src="{{site.url}}/images/vignette/lognormal_plot-1.png" width=300>
</div>
<br>

<h2>Classifying and Counting Cells</h2>

Single cell experiments are often performed on complex mixtures of multiple cell types.
Dissociated tissue samples might contain two, three, or even many different cells types.
In such cases, it's often nice to classify cells based on type using known markers.
In the myoblast experiment, the culture contains fibroblasts that came from the original muscle biopsy used to establish the primary cell culture.
Myoblasts express some key genes that fibroblasts don't.
Selecting only the genes that express, for example, sufficiently high levels of <i>MYF5</i> excludes the fibroblasts.
Likewise, fibroblasts express high levels of <i>ANPEP</i> (CD13), while myoblasts tend to express few if any transcripts of this gene.

<br>
<br>

<h3>Classifying cells with CellTypeHierarchy </h3>
Monocle provides a simple system for tagging cells based on the expression of marker genes of your choosing.
You simply provide a set of functions that Monocle can use to annotate each cell.
For example, you could provide a function for each of several cell types.
These functions accept as input the expression data for each cell, and return TRUE to tell Monocle that a cell meets the criteria defined by the function.
So you could have one function that returns TRUE for cells that express myoblast-specific genes, another function for fibroblast-specific genes, etc.
Here's an example of such a set of "gating" functions:
<br>
<br>

{% highlight R %}
MYF5_id <- row.names(subset(fData(HSMM), gene_short_name == "MYF5"))
 ANPEP_id <- row.names(subset(fData(HSMM), gene_short_name == "ANPEP"))

 cth <- newCellTypeHierarchy()
 cth <- addCellType(cth, "Myoblast", classify_func=function(x) {x[MYF5_id,] >= 1})
 cth <- addCellType(cth, "Fibroblast", classify_func=function(x)
        {x[MYF5_id,] < 1 & x[ANPEP_id,] > 1})
{% endhighlight %}

<br>
<br>

The functions are organized into a small data structure called a <i>CellTypeHierarchy</i>, that Monocle uses to classify the cells.
You first initialize a new CellTypeHierarchy object, then register your gating functions within it.
Once the data structure is set up, you can use it to classify all the cells in the experiment:

{% highlight R %}
HSMM <- classifyCells(HSMM, cth, 0.1)
{% endhighlight %}

<br>
<br>

The function <i>classifyCells</i> applies each gating function to each cell, classifies the cells according to the gating functions, and returns the <i>CellDataSet</i> with a new column, <i>CellType</i> in its <i>pData</i> table.
We can now count how many cells of each type there are in the experiment.

<br>
<br>

{% highlight R %}
table(pData(HSMM)$CellType)

 pie <- ggplot(pData(HSMM), aes(x = factor(1), fill = factor(CellType))) +
   geom_bar(width = 1)
 pie + coord_polar(theta = "y") +
   theme(axis.title.x=element_blank(), axis.title.y=element_blank())
{% endhighlight %}

<br>
<br>

Note that many cells are marked "Unknown".
This is common, largely because of the low rate of mRNA capture in most single-cell RNA-Seq experiments.
A cell might express a few <i>MYF5</i> mRNAs, but we weren't lucky enough to capture one of them.
When a cell doesn't meet any of the criteria specified in your classification functions, it's marked "Unknown".
If it meets multiple functions' criteria, it's marked "Ambiguous". You could just exclude such cells, but you'd be throwing out a lot of your data.
In this case, we'd lose more than half of the cells!

<h3> Unsupervised Cell Clustering </h3>
Monocle provides an algorithm you can use to impute the types of the "Unknown" cells.
This algorithm, implemented in the function <code>clusterCells</code>, groups cells together according to global expression profile.
That way, if your cell expresses lots of genes specific to myoblasts, but just happens to lack <i>MYF5</i>, we can still recognize it as a myoblast.
<code>clusterCells</code> can be used in an unsupervised manner, as well as in a ``semi-supervised'' mode, which allows to assist the algorithm with some expert knowledge.
Let's look at the unsupervised mode first.

<br>
<br>

The first step is to decide which genes to use in clustering the cells.
We could use all genes, but we'd be including a lot of genes that are not expressed at a high enough level to provide a meaningful signal.
Including them would just add noise to the system. We can filter genes based on average expression level, and we can additionally select genes that are unusually variable across cells.
These genes tend to be highly informative about cell state.

<br>
<br>

{% highlight R%}
disp_table <- dispersionTable(HSMM)
unsup_clustering_genes <- subset(disp_table, mean_expression >= 0.1)
HSMM <- setOrderingFilter(HSMM, unsup_clustering_genes$gene_id)
plot_ordering_genes(HSMM)
{% endhighlight %}

<br>
<br>

The <code>setOrderingFilter</code> function marks genes that will be used for clustering in subsequent calls to <code>clusterCells</code>, although we will be able to provide other lists of genes if we want.
The <code>plot_ordering_genes</code> function shows how variability (dispersion) in a gene's expression depends on the average expression across cells.
The red line shows Monocle's expectation of the dispersion based on this relationship.
The genes we marked for use in clustering are shown as black dots, while the others are shown as grey dots.

<br>
<br>

Now we're ready to try clustering the cells:

{% highlight R %}
# HSMM@auxClusteringData[["tSNE"]]$variance_explained <- NULL
plot_pc_variance_explained(HSMM, return_all = F) # norm_method = 'log',
HSMM <- reduceDimension(HSMM, max_components=2, num_dim = 6,
                        reduction_method = 'tSNE', verbose = T)
HSMM <- clusterCells(HSMM,
                     num_clusters=2)
plot_cell_clusters(HSMM, 1, 2, color="CellType", markers=c("MYF5", "ANPEP"))
{% endhighlight %}

<br>

Monocle uses t-SNE \cite{Maaten2008-om} to cluster cells, using an approach that's very similar to and inspired by Rahul Satija's excellent \href{http://satijalab.org/seurat/}{Seurat} package, which itself was inspired by \href{https://www.c2b2.columbia.edu/danapeerlab/html/cyt.html}{viSNE} from Dana Pe'er's lab.

<br>
<br>

The cells tagged as myoblasts by our gating functions are marked in green, while the fibroblasts are tagged in red. The cells that don't express either marker are blue. In many experiments, cells of different types are clearly separate from one another. Unfortunately, in this experiment, the cells don't simply cluster by type - there's not a clear space between the green cells and the red cells. This isn't all that surprising, because myoblasts and contaminating interstitial fibroblasts express many of the same genes in these culture conditions, and there are multiple culture conditions in the experiment. That is, there are other sources of variation in the experiment that might be driving the clustering. One source of variation in the experiment stems from the experimental design. To initiate myoblast differentiation, we switch media from a high-mitogen growth medium (GM) to a low-mitogen differentiation medium (DM). Perhaps the cells are clustering based on the media they're cultured in?

<br>

{% highlight R%}
plot_cell_clusters(HSMM, 1, 2, color="Media")
{% endhighlight %}

<br>

Monocle allows us to subtract the effects of "uninteresting" sources of variation to reduce their impact on the clustering.
You can do this with the <i>residualModelFormulaStr</i> argument to <code>clusterCells</code> and several other Monocle functions.
This argument accepts an R model formula string specifying the effects you want to subtract prior to clustering.


<br>

{% highlight R %}
HSMM <- reduceDimension(HSMM, max_components=2, num_dim = 2, reduction_method = 'tSNE',
                       residualModelFormulaStr="~Media + num_genes_expressed", verbose = T) #
HSMM <- clusterCells(HSMM, num_clusters=2)
plot_cell_clusters(HSMM, 1, 2, color="CellType")
{% endhighlight %}


<br>

Now that we've accounted for some unwanted sources of variation, we're ready to take another crack at classifying the cells by unsupervised clustering:

<br>


{% highlight R %}
HSMM <- clusterCells(HSMM, num_clusters=2)
plot_cell_clusters(HSMM, 1, 2, color="Cluster") + facet_wrap(~CellType)
{% endhighlight %}

<br>

Now, most of the myoblasts are in one cluster, most of the fibroblasts are in the other, and the unknowns are spread across both.
However, we still see some cells of both types in each cluster.
This could be due to lack of specificity in our marker genes and our CellTypeHierarchy functions, but it could also be due to suboptimal clustering.
To help rule out the latter, let's try running <code>clusterCells</code> in its semi-supervised mode.

<br>
<br>

<h3> Semi-Supervised Cell Clustering with Known Marker Genes </h3>

First, we'll select a different set of genes to use for clustering the cells.
Before we just picked genes that were highly expressed and highly variable.
Now, we'll pick genes that <i>co-vary</i> with our markers.
In a sense, we'll be building a large list of genes to use as markers, so that even if a cell doesn't have <i>MYF5</i>, it might be recognizable as a myoblast based on other genes.

<br>
<br>

{% highlight R %}
marker_diff <- markerDiffTable(HSMM[expressed_genes,],
                                 cth,
                                 residualModelFormulaStr="~Media + num_genes_expressed",
                                 cores=1)
{% endhighlight%}

<br>

The function <code>markerDiffTable</code> takes a CellDataSet and a CellTypeHierarchy and classifies all the cells into types according to your provided functions.
It then removes all the "Unknown" and "Ambiguous" functions before identifying genes that are differentially expressed between the types.
Again, you can provide a residual model of effects to exclude from this test.
The function then returns a data frame of test results, and you can use this to pick the genes you want to use for clustering.
Often it's best to pick the top 10 or 20 genes that are most specific for each cell type.
This ensures that the clustering genes aren't dominated by markers for one cell type.
You generally want a balanced panel of markers for each type if possible.
Monocle provides a handy function for ranking genes by how restricted their expression is for each type.

<br>
<br>

{% highlight R %}
candidate_clustering_genes <- row.names(subset(marker_diff, qval < 0.01))
marker_spec <- calculateMarkerSpecificity(HSMM[candidate_clustering_genes,], cth)
head(selectTopMarkers(marker_spec, 3))
{% endhighlight %}

<br>

The last line above shows the top three marker genes for myoblasts and fibroblasts.
The "specificity" score is calculated using the metric described in Cabili et al \cite{CABILI} and can range from zero to one.
The closer it is to one, the more restricted it is to the cell type in question.
You can use this feature to define new markers for known cell types, or pick out genes you can use in purifying newly discovered cell types.
This can be highly valuable for downstream follow up experiments.

<br>
<br>
To cluster the cells, we'll choose the top 500 markers for each of these cell types:
{% highlight R %}

semisup_clustering_genes <- unique(selectTopMarkers(marker_spec, 500)$gene_id)
HSMM <- setOrderingFilter(HSMM, semisup_clustering_genes)
plot_ordering_genes(HSMM)

{% endhighlight %}

<br>

Note that we've got smaller set of genes, and some of them are not especially highly expressed or variable across the experiment.
However, they are great for distinguishing cells that express <i>MYF5</i> from those that have <i>ANPEP</i>.
We've already marked them for use in clustering, but even if we hadn't, we could still use them by providing them directly to <code>clusterCells</code>.

<br>
<br>

{% highlight R %}
plot_pc_variance_explained(HSMM, return_all = F)
HSMM <- reduceDimension(HSMM, max_components=2, num_dim = 3, norm_method = 'log', reduction_method = 'tSNE',
                       residualModelFormulaStr="~Media + num_genes_expressed", verbose = T)
HSMM <- clusterCells(HSMM, num_clusters=2)

plot_cell_clusters(HSMM, 1, 2, color="CellType")
{% endhighlight %}

<h3> Imputing Cell Type </h3>
Note that we've reduce the number of "contaminating" fibroblasts in the myoblast cluster, and vice versa.
But what about the "Unknown" cells? If you provide  <code>clusterCells</code> with a the CellTypeHierarcy, Monocle will use it classify <i>whole clusters</i>, rather than just individual cells.
Essentially, cluserCells works exactly as before, except after the clusters are built, it counts the frequency of each cell type in each cluster.
When a cluster is composed of more than a certain percentage (in this case, 10\%) of a certain type, all the cells in the cluster are set to that type.
If a cluster is composed of more than one cell type, the whole thing is marked "Ambiguous".
If there's no cell type thats above the threshold, the cluster is marked "Unknown".
Thus, Monocle helps you impute the type of each cell even in the presence of missing marker data.
<br>
<br>


{% highlight R%}
HSMM <- clusterCells(HSMM,
                      num_clusters=2,
                      frequency_thresh=0.1,
                      cell_type_hierarchy=cth)
 plot_cell_clusters(HSMM, 1, 2, color="CellType", markers = c("MYF5", "ANPEP"))
{% endhighlight%}

<br>

As you can see, the clusters are fairly pure in terms of <i>MYF5</i> expression.
There are some cells expressing <i>ANPEP</i> in both clusters, but those in the myoblast cluster also express <i>MYF5</i>.
This is not surprising, as ANPEP isn't a very specific marker of fibroblasts.
Overall, we've successfully classified all the cells:
<br>
<br>

{% highlight R %}
pie <- ggplot(pData(HSMM), aes(x = factor(1), fill = factor(CellType))) +
   geom_bar(width = 1)
 pie + coord_polar(theta = "y") +
   theme(axis.title.x=element_blank(), axis.title.y=element_blank())
{% endhighlight %}
<br>
<br>

Finally, we subset the CellDataSet object to create <em>HSMM_myo</em>, which includes only myoblasts.
We'll use this in the rest of the analysis.
<br>
<br>

{% highlight R %}

HSMM_myo <- HSMM[,pData(HSMM)$CellType == "Myoblast"]
HSMM_myo <- estimateDispersions(HSMM_myo)

{% endhighlight %}

<h2> Constructing Single Cell Trajectories </h2>
During development, in response to stimuli, and througout life, cells transition from one functional "state" to another.
Cells in different states express different sets of genes, producing a dynamic repetoire of proteins and metabolites that carry out their work.
As cells move between states, undergo a process of transcriptional re-configuration, with some genes being silenced and others newly activated.
These transient states are often hard to characterize because purifying cells in between more stable endpoint states can be difficult or impossible.
Single-cell RNA-Seq can enable you to see these states without the need for purification.
However, to do so, we must determine where each cell is the range of possible states.

<br>
<br>

Monocle introduced the strategy of using RNA-Seq for <em>single cell trajectory analysis</em>.
Rather than purifying cells into discrete states experimentally, Monocle uses an algorithm to learn the sequence of gene expression changes each cell must go through as part of a dynamic biological process.
Once it has learned the overall "trajectory" of gene expression changes, Monocle can place each cell at its proper position in the trajectory.
You can then use Monocle's differential analysis toolkit to find genes regulated over the course of the trajectory, as described in section 6.3.
If there are multiple outcome for the process, Monocle will reconstruct a "branched" trajectory.
These branches correspond to cellular "decisions", and Monocle provides powerful tools for identifying the genes affected by them and involved in making them.
You can see how to analyze branches in section 9.6.
Monocle relies on a machine learning technique called <em>reversed graph embedding</em> to construct single-cell trajectories.
You can read more about the theoretical foundations of Monocle's approach in section 9, or consult the references shown at the end of the vignette.

<h3> 5.1 "Pseudotime": A Measure of Progress Through a Biological Process </h3>

In many biological processes, cells do not progress in perfect synchrony.  In single-cell expression studies of processes such as cell differentiation, captured cells might be widely distributed in terms of progress.  That is, in a population of cells captured at exactly the same time, some cells might be far along, while others might not yet even have begun the process.  This asynchrony creates major problems when you want to understand the sequence of regulatory changes that occur as cells transition from one state to the next. Tracking the expression across cells captured at the same time produces a very compressed sense of a gene's kinetics, and the apparent variability of that gene's expression will be very high.

By ordering each cell according to its progress along a learned trajectory, Monocle alleviates the problems that arise due to asynchrony. Instead of tracking changes in expression as a function of time, Monocle tracks changes as a function of progress along the trajectory, which we term ``pseudotime''. Pseudotime is an abstract unit of progress: it's simply the distance between a cell and the start of the trajectory, measured along the shortest path. The trajectory's total length is defined in terms of the total amount of transcriptional change that a cell undergoes as it moves from the starting state to the end state. For further details, see section 9.

<h3> 5.2 The Ordering Algorithm </h3>

<br>

<h4> 5.2.1 Choosing Genes for Ordering </h4>

Inferring a single-cell trajectory is a hard machine learning problem.
The first step is to select the genes Monocle will use as input for its machine learning approach.
This is called <em>feature selection</em>, and it has a major impact in the shape of the trajectory.
In single-cell RNA-Seq, genes expressed at low levels are often very noisy, but some may contain important information regarding the state of the cell.
If we simply provide all the input data, Monocle might get confused by the noise, or fix on a feature of the data that isn't biologically meaningful, such as batch effects arising from collecting data on different days.
Monocle provides you with a variety of tools to select genes that will yield a robust, accurate, and biologically meaningful trajectory.
You can use these tools to either perform a completely "unsupervised" analysis, in which Monocle has no forehand knowledge of which gene you consider important.
Alternatively, you can make use of expert knowledge in the form of genes that are already known to define biolgical progress to shape Monocle's trajectory.
We consider this mode "semi-supervised", because Monocle will augment the markers you provide with other, related genes. Monocle then uses these genes to produce trajectories consistent with known biology but that often reveal new regulatory structure. We return to the muscle data to illustrate both of these modes.

<h4> 5.2.2 Reducing the Dimensionality of the Data </h4>
Once we have selected the genes we will use to order the cells, Monocle applies a <em>dimensionality reduction</em> to the data, which will drastically improves the quality of the trajectory.
Monocle reduces the dimensionality of the data with the <code>reduceDimension</code> function. This function has a number of options, so you should familiarize yourself with them by consulting the its manual page. You can choose from two algorithms in <code>reduceDimension</code>. The first, termed Independent Component Analysis, is a classic linear technique for decomposing data that powered the original version of Monocle. The second, called DDRTree, is a much more powerful nonlinear technique that is the default for Monocle 2.  For more on how these both work, see section 9.

<h4> 5.2.3 Ordering the Cells in Pseudotime </h4>
With the expression data projected into a lower dimensional space, Monocle is ready to learn the trajectory that describes how cells transition from one state into another. Monocle assumes that the trajectory has a tree structure, with one end of it the "root", and the others the "leaves". A cell at the beginning of the biological process starts at the root and progresses along the trunk until it reaches the first branch, if there is one. It then chooses a branch, and moves further and further along the tree until it reaches a leaf. These mathematical assumptions translate into some important biological ones. First, that the data includes all the major stages of the biological process. If your experiment failed to capture any cells at a key developmental transition, Monocle won't know its there. Second, that gene expression changes are smooth as a cell moves from one stage to the next. This assumption is realistic: major discontinuities in the trajectory would amount to a cell almost instantaneously turning over its transcriptome, which probably doesn't happen in most biolgical processes.

<br>
<br>

To order your cells, Monocle uses the <code>orderCells</code> function.
This routine has one important argument, which allows you to set the root of the tree, and thus the beginning of the process.
See the manual page for <code>orderCells</code> for more details.

<h3> 5.3 Unsupervised Ordering </h3>

In this section, we discuss ordering cells in a completely unsupervised fashion.
First, we must decide which genes we will use to define a cell's progress through myogenesis.
Monocle orders cells by examining the pattern of expression of these genes across the cell population.
Monocle looks for genes that vary in "interesting" (i.e. not just noisy) ways, and uses these to structure the data.
We ultimately want a set of genes that increase (or decrease) in expression as a function of progress through the process we're studying.

<br>
<br>

Ideally, we'd like to use as little prior knowledge of the biology of the system under study as possible.
We'd like to discover the important ordering genes from the data, rather than relying on literature and textbooks, because that might introduce bias in the ordering.
One effective way to isolate a set of ordering genes is to simply compare the cells collected at the beginning of the process to those at the end and find the differentially expressed genes, as described above.
The command below will find all genes that are differentially expressed in response to the switch from growth medium to differentiation medium:

{% highlight R %}
diff_test_res <- differentialGeneTest(HSMM_myo[expressed_genes,],
                                       fullModelFormulaStr="~Media")
 ordering_genes <- row.names (subset(diff_test_res, qval < 0.01))
{% endhighlight %}

<br>

Choosing genes based on differential analysis of time points is often highly effective, but what if we don't have time series data?
If the cells are asynchronously moving through our biological process (as is usually the case), Monocle can often reconstruct their trajectory from a single population captured all at the same time.
Below are two methods to select genes that require no knowledge of the design of the experiment at all.

<br>
<br>

<h4> 5.3.1 Selecting Genes with High Dispersion Across Cells </h4>
Genes that vary a lot are often highly informative for identifying cell subpopulations or ordering cells along a trajectory. In RNA-Seq, a gene's variance typically depends on its mean, so we have to be a bit careful about how we select genes based on their variance.

<br>
<br>

{% highlight R %}
disp_table <- dispersionTable(HSMM_myo)
 ordering_genes <- subset(disp_table,
                          mean_expression >= 0.5 &
                          dispersion_empirical >= 1 * dispersion_fit)$gene_id
{% endhighlight %}

<br>

Once we have a list of gene ids to be used for ordering, we need to set them in the <em>HSMM</em> object, because the next several functions will depend on them.

<br>
<br>

{% highlight R %}
HSMM_myo <- setOrderingFilter(HSMM_myo, ordering_genes)
plot_ordering_genes(HSMM_myo)
{% endhighlight %}

<br>

The genes we've chosen to use for ordering define the <em>state space</em> of the cells in our data set.
Each cell is a point in this space, which has dimensionality equal to the number of genes we've chosen.
So if there are 500 genes used for ordering, each cell is a point in a 500-dimensional space.
For a number of reasons, Monocle works better if we can <em>reduce</em> the dimensionality of that space before we try to put the cells in order.
In this case, we will reduce the space down to one with two dimensions, which we will be able to easily visualize and interpret while Monocle is ordering the cells.

<br>
<br>

{% highlight R %}
HSMM_myo <- reduceDimension(HSMM_myo, max_components=2, method = 'DDRTree')
{% endhighlight %}

<br>

Now that the space is reduced, it's time to order the cells using the <code>orderCells</code> function as shown below.
<br>
<br>

{% highlight R %}
HSMM_myo <- orderCells(HSMM_myo)
{% endhighlight %}

<br>

Once the cells are ordered, we can visualize the trajectory in the reduced
dimensional space.
<br>
<br>

{% highlight R %}
plot_cell_trajectory(HSMM_myo, color_by="Hours")
{% endhighlight %}
<br>

The trajectory has a tree-like structure. We can see that the cells
 collected at time zero are located near one of the tips of the tree, while the
 others are distributed amongst the two "branches".  Monocle doesn't know
 <em>a priori</em> which of the trajectory of the tree to call the "beginning",
 so we often have to call <code>orderCells</code> again using the
 <code>root_state</code> argument to specify the beginning. First, we plot the
 trajectory, this time coloring the cells by "State":

<br>

 {% highlight R %}
 plot_cell_trajectory(HSMM_myo, color_by="State")
 {% endhighlight %}

<br>

 "State" is just Monocle's term for the segment of the tree. The function below is handy for identifying the State which contains most of the cells from time zero. We can then pass that to <code>orderCells</code>:

<br>

 {% highlight R %}
 GM_state <- function(cds){
  if (length(unique(pData(cds)$State)) > 1){
    T0_counts <- table(pData(cds)$State, pData(cds)$Hours)[,"0"]
    return(as.numeric(names(T0_counts)[which(T0_counts == max(T0_counts))]))
  }else { return (1) }
}
HSMM_myo <- orderCells(HSMM_myo, root_state=GM_state(HSMM_myo))
plot_cell_trajectory(HSMM_myo, color_by="Pseudotime")
 {% endhighlight %}

 <br>

 If there are a ton of states in your tree, it can be a little hard to make out where each one falls on the tree.  Sometimes it can be handy to "facet" the trajectory plot so it's easier to see where each of the states are located:

<br>

 {% highlight R %}
 plot_cell_trajectory(HSMM_myo, color_by="State") + facet_wrap(~State, nrow=1)
 {% endhighlight %}

 <br>
 <br>

 And if you don't have a timeseries, you might need to set the root based on where certain marker genes are expressed, using your biological knowledge of the system.
 For example, in this experiment, a highly proliferative population of progenitor cells are generating two types of post-mitotic cells.
 So the root should have cells that express high levels of proliferation markers.
 We can use the jitter plot to pick figure out which state corresponds to rapid proliferation:

{% highlight R %}
blast_genes <- row.names(subset(fData(HSMM_myo), gene_short_name %in% c("CCNB2", "MYOD1", "MYOG")))
plot_genes_jitter(HSMM_myo[blast_genes,], grouping="State", min_expr=0.1)
{% endhighlight %}

<br>

To confirm that the ordering is correct we can select a couple of markers of myogenic progress.
Plotting these genes demonstrates that ordering looks good:

{% highlight R %}
HSMM_expressed_genes <-  row.names(subset(fData(HSMM_myo), num_cells_expressed >= 10))
HSMM_filtered <- HSMM_myo[HSMM_expressed_genes,]

my_genes <- row.names(subset(fData(HSMM_filtered),
                              gene_short_name %in% c("CDK1", "MEF2C", "MYH3")))

cds_subset <- HSMM_filtered[my_genes,]
plot_genes_in_pseudotime(cds_subset, color_by="Hours")
{% endhighlight %}

<strong>Note:</strong> in the event that Monocle produces a linear trajectory, there will only
be one state. In this case, you can tell it which end is the beginning of the
trajectory by passing <code>orderCells</code> an optional argument argument: the
<i>reverse</i> flag. The <i>reverse</i> flag tells Monocle to reverse the
orientation of the entire process as it's being discovered from the data,
so that the cells that would have been assigned to the end are instead assigned
to the beginning, and so on.

<h4> 5.3.2 Selecting Genes Based on PCA Loading </h4>
A number of single-cell clustering studies have found that principal component
analysis (PCA) is an effective way of finding genes that vary widely across cells. You
can use PCA to pick out a good set of ordering genes in a completely unsupervised
manner. The procedure below first normalizes the expression data by adding a
pseudocount, log-transforming it, and then standardizing it so that all genes
have roughly the same dynamic range.  Then, it uses the <i>irlba</i> package
to perform the PCA. The code below is a little more complicated than just calling
<code>prcomp</code>, but it has the advantage of performing the entire computation
with sparse matrix operations. This is important for large, sparse CellDataSet
objects like the ones common in droplet-based single-cell RNA-Seq.

{% highlight R %}
HSMM_myo <- HSMM_myo[HSMM_expressed_genes,]
exprs_filtered <- t(t(exprs(HSMM_myo)/pData(HSMM_myo)$Size_Factor))
#nz_genes <- which(exprs_filtered != 0, arr.ind = T)
exprs_filtered@x <- log(exprs_filtered@x + 1)

# Calculate the variance across genes without converting to a dense
# matrix:
expression_means <- Matrix::rowMeans(exprs_filtered)
expression_vars <- Matrix::rowMeans((exprs_filtered - expression_means)^2)

# Filter out genes that are constant across all cells:
genes_to_keep <- expression_vars > 0
exprs_filtered <- exprs_filtered[genes_to_keep,]
expression_means <- expression_means[genes_to_keep]
expression_vars <- expression_vars[genes_to_keep]

# Here's how to take the top PCA loading genes, but using
# sparseMatrix operations the whole time, using irlba. Note
# that the v matrix from irlba is the loading matrix
set.seed(0)
irlba_pca_res <- irlba(t(exprs_filtered),
                       nu=0,
                       center=expression_means,
                       scale=sqrt(expression_vars),
                       right_only=TRUE)$v

row.names(irlba_pca_res) <- row.names(exprs_filtered)

# Here, we will just
# take the top 200 genes from components 2 and 3.
# Component 1 usually is driven by technical noise.
# We could also use a more principled approach,
# similar to what dpFeature does below
PC2_genes <- names(sort(abs(irlba_pca_res[, 2]), decreasing = T))[1:200]
PC3_genes <- names(sort(abs(irlba_pca_res[, 3]), decreasing = T))[1:200]

ordering_genes <- union(PC2_genes, PC3_genes)
{% endhighlight %}

Using these to order the cells as above yields the following trajectory:
{% highlight R %}
HSMM_myo <- setOrderingFilter(HSMM_myo, ordering_genes)
HSMM_myo <- reduceDimension(HSMM_myo, max_components=2, method = 'DDRTree')
HSMM_myo <- orderCells(HSMM_myo)
HSMM_myo <- orderCells(HSMM_myo, root_state=GM_state(HSMM_myo))
plot_cell_trajectory(HSMM_myo, color_by="Hours")
{% endhighlight %}

<h3> 5.4 Unsupervized Feature Selection Based on Density Peak Clustering </h3>

Selecting genes for ordering cells using the techniques discussed above often
works well in simple settings, but for more complex processes, we recommend a
new procedure called "dpFeature". This procedure works by first projecting
cells into two dimensions using t-SNE and then detecting clusters using the
``densityPeak'' algorithm of Rodriguez and Laio \cite{RodriguezLaio}. The
resulting clusters of cells are compared using Monocle's differential expression
analysis functions to find genes that distinguish them. The top of these are
then used to order cells.

<br>
<br>

To use dpFeature, we first select superset of feature genes as genes expressed
in at least <em>5%</em> of all the cells.

{%highlight R%}
HSMM_myo <- detectGenes(HSMM_myo, min_expr=0.1)
fData(HSMM_myo)$use_for_ordering <- fData(HSMM_myo)$num_cells_expressed > 0.05 * ncol(HSMM_myo)
{% endhighlight %}

Then we will perform a PCA analysis to identify the variance explained by each PC (principal component).
We can look at a scree plot and determine how many pca dimensions are wanted based on whether or not there is a
significant gap between that component and the component after it. By selecting only the high loading PCs,
we effectively only focus on the more interesting biological variations.

{% highlight R %}
plot_pc_variance_explained(HSMM_myo, return_all = F)
{% endhighlight %}

We will then run reduceDimension with t-SNE as the reduction method on those top PCs and project them further down to two dimensions.

{% highlight R %}
HSMM_myo <- reduceDimension(HSMM_myo, max_components=2, norm_method = 'log', num_dim = 3,
                              reduction_method = 'tSNE', verbose = T)
{% endhighlight %}

Then we can run density peak clustering to identify the clusters on the 2-D t-SNE space. Density peak algorithm clusters cells based on each
cell's local density (&Rho) and the nearest distance &Delta of a cell to another cell with higher distance. We can set a threshold for
the &Rho, &Delta and define any cell with a higher local density and distance than the thresholds as the density peaks. Those peaks are then
used to define the clusters for all cells. By default, <code>clusterCells</code> choose <em>95%</em> of &Rho and &Delta to define
the thresholds. We can also set a number of clusters <em>(n)</em> we want to cluster. In this setting, we will find the top <em>n</em> cells with high
&Delta with &Delta among the top <em>50%</em> range. The default setting often gives good clustering.

{% highlight R %}
HSMM_myo <- clusterCells(HSMM_myo, verbose = F)
{% endhighlight %}

After the clustering, we can check the clustering results.
{%highlight R%}
plot_cell_clusters(HSMM_myo, color_by = 'as.factor(Cluster)')
plot_cell_clusters(HSMM_myo, color_by = 'as.factor(Hours)')
{% endhighlight %}

We also provide the decision plot for users to check the &Rho, &Delta for each cell and decide the threshold for defining the cell clusters.

{% highlight R %}
plot_rho_delta(HSMM_myo, rho_threshold = 2, delta_threshold = 4 )
{% endhighlight %}

We could then re-run clustering based on the user defined threshold. To
facilitate the computation, we can set <code>(skip\_rho\_sigma = T)</code>
which enables us to skip the calculation of the &Rho, &Sigma.

{% highlight R %}
HSMM_myo <- clusterCells(HSMM_myo,
                         rho_threshold = 2,
                         delta_threshold = 4,
                         skip_rho_sigma = T,
                         verbose = F)
{% endhighlight %}

We can check the final clustering results as following:
{% highlight R %}
plot_cell_clusters(HSMM_myo, color_by = 'as.factor(Cluster)')
plot_cell_clusters(HSMM_myo, color_by = 'as.factor(Hours)')
{% endhighlight %}

After we confirm the clustering makes sense, we can then perform differential
gene expression test as a way to extract the genes that distinguish them.

{%highlight R %}
clustering_DEG_genes <- differentialGeneTest(HSMM_myo[HSMM_expressed_genes,],
                                             fullModelFormulaStr = '~Cluster',
                                             cores = 1)
{% endhighlight %}

We will then select the top <em>1000</em> significant genes as the ordering genes.

{% highlight R %}
HSMM_ordering_genes <- row.names(clustering_DEG_genes)[order(clustering_DEG_genes$qval)][1:1000]

HSMM_myo <- setOrderingFilter(HSMM_myo, ordering_genes = HSMM_ordering_genes)
HSMM_myo <- reduceDimension(HSMM_myo, method = 'DDRTree')
HSMM_myo <- orderCells(HSMM_myo)
HSMM_myo <- orderCells(HSMM_myo, root_state=GM_state(HSMM_myo))
plot_cell_trajectory(HSMM_myo, color_by="Hours")
{% endhighlight %}

<hd3> Semi-Supervised Ordering with Known Marker Genes </hd3>
Unsupervised ordering is desirable because it avoids introducing bias into the analysis. However, unsupervised machine learning will often fix on a strong feature of the data that's not the focus of your experiment. For example, where each cell is in the cell cycle has a major impact on the shape of the trajectory when you use unsupervised learning. But what if you wish to focus on cycle-independent effects in your biological process? Monocle's "semi-supervised" ordering mode can help you focus on the aspects of the process you're interested in.

Ordering your cells in a semi-supervised manner is very simple. You first define genes that mark progress using the <em>CellTypeHierchy</em> system, very similar to how we used it for cell type classification. Then, you use it to select ordering genes that co-vary with these markers. Finally, you order the cell based on these genes just as we do in unsupervised ordering. So the only difference between unsupervised and semi-supervised ordering is in which genes we use for ordering.

As we saw before, myoblasts begin differnentation by exiting the cell cycle and then proceed through a sequence of regulatory events that leads to expression of some key muscle-specific proteins needed for contraction. We can mark cycling cells with cyclin B2 <em>(CCNB2)</em> and recognize myotubes as those cells expressed high levels of myosin heavy chain 3 <em>(MYH3)</em>.
{% highlight R %}
CCNB2_id <- row.names(subset(fData(HSMM_myo), gene_short_name == "CCNB2"))
MYH3_id <- row.names(subset(fData(HSMM_myo), gene_short_name == "MYH3"))

cth <- newCellTypeHierarchy()
cth <- addCellType(cth, "Cycling myoblast", classify_func=function(x) {x[CCNB2_id,] >= 1})
cth <- addCellType(cth, "Myotube", classify_func=function(x) {x[MYH3_id,] >=1})
cth <- addCellType(cth, "Reserve cell", classify_func=function(x) {x[MYH3_id,] == 0 & x[CCNB2_id,] == 0})
HSMM_myo <- classifyCells(HSMM_myo, cth)
{% endhighlight %}

Now we select the set of genes that co-vary (in either direction) with these two "bellweather" genes:
{% highlight R%}
marker_diff <- markerDiffTable(HSMM_myo[HSMM_expressed_genes,],
                               cth,
                               cores=1)
#semisup_clustering_genes <- row.names(subset(marker_diff, qval < 0.05))
semisup_clustering_genes <- row.names(marker_diff)[order(marker_diff$qval)][1:1000]
{% endhighlight %}

Using the top 1000 genes for ordering produces a trajectory that's highly similar to the one we obtained with unsupervised methods, but it's a little "cleaner".
{% highlight R %}
HSMM_myo <- setOrderingFilter(HSMM_myo, semisup_clustering_genes)
#plot_ordering_genes(HSMM_myo)
HSMM_myo <- reduceDimension(HSMM_myo, max_components=2, method = 'DDRTree', norm_method = 'log')
HSMM_myo <- orderCells(HSMM_myo)
HSMM_myo <- orderCells(HSMM_myo, root_state=GM_state(HSMM_myo))
plot_cell_trajectory(HSMM_myo, color_by="CellType") + theme(legend.position="right")
{% endhighlight %}

To confirm that the ordering is correct, we can select a couple of markers of
myogenic progress. In this experiment, one of the branches corresponds to cells
that successfully fuse to form myotubes, and the other to those that fail to
fully differentiate. We'll exclude the latter for now, but you can learn more
about tools for dealing with branched trajectories in section 7.

{% highlight R %}
HSMM_filtered <- HSMM_myo[HSMM_expressed_genes,]

my_genes <- row.names(subset(fData(HSMM_filtered),
                             gene_short_name %in% c("CDK1", "MEF2C", "MYH3")))

cds_subset <- HSMM_filtered[my_genes,]
plot_genes_branched_pseudotime(cds_subset,
                               branch_point=1,
                               color_by="Hours",
                               ncol=1)
{% endhighlight %}

<h2> Differential Expression Analysis </h2>
Differential gene expression analysis is a common task in RNA-Seq experiments.  Monocle can help you find genes that are differentially expressed between groups of cells and assesses the statistical signficance of those changes. These comparisons require that you have a way to collect your cells into two or more groups.  These groups are defined by columns in the <em>phenoData</em> table of each <em>CellDataSet</em>.  Monocle will assess the signficance of each gene's expression level across the different groups of cells.

<h3> Basic Differential Analysis </h3>
Performing differential expression analysis on all genes in the human genome can take a substantial amount of time. For a dataset as large as the myoblast data from \cite{TRAPNELL_CACCHIARELLI}, which contains several hundred cells, the analysis can take several hours on a single CPU. Let's select a small set of genes that we know are important in myogenesis to demonstrate Monocle's capabilities:

{% highlight R %}
marker_genes <- row.names(subset(fData(HSMM_myo),
                                 gene_short_name %in% c("MEF2C", "MEF2D", "MYF5",
                                                        "ANPEP", "PDGFRA","MYOG",
                                                        "TPM1",  "TPM2",  "MYH2",
                                                        "MYH3",  "NCAM1", "TNNT1",
                                                        "TNNT2", "TNNC1", "CDK1",
                                                        "CDK2",  "CCNB1", "CCNB2",
                                                        "CCND1", "CCNA1", "ID1")))
{% endhighlight %}

In the myoblast data, the cells collected at the outset of the experiment were cultured in ``growth medium'' (GM) to prevent them from differentiating.  After they were harvested, the rest of the cells were switched over to ``differentiation medium'' (DM) to promote differentiation. Let's have monocle find which of the genes above are affected by this switch:
{% highlight R %}
diff_test_res <- differentialGeneTest(HSMM_myo[marker_genes,],
                                      fullModelFormulaStr="~Media")

# Select genes that are significant at an FDR < 10%
sig_genes <- subset(diff_test_res, qval < 0.1)

sig_genes[,c("gene_short_name", "pval", "qval")]
{% endhighlight %}

So most of the 22 genes are significant at a 10\% false discovery rate! This isn't surprising, as most of the above genes are highly relevant in myogenesis. Monocle also provides some easy ways to plot the expression of a small set of genes grouped by the factors you use during differential analysis.  This helps you visualize the differences revealed by the tests above.  One type of plot is a "jitter" plot.

{% highlight R %}
MYOG_ID1 <- HSMM_myo[row.names(subset(fData(HSMM_myo),
                                      gene_short_name %in% c("MYOG", "CCNB2"))),]
plot_genes_jitter(MYOG_ID1, grouping="Media", ncol=2)
{% endhighlight %}

Note that we can control how to layout the genes in the plot by specifying the number of rows and columns.  See the man page on <code>plot_genes_jitter</code> for more details on controlling its layout. Most if not all of Monocle's plotting routines return a plot object from the <em>ggplot2</em> package.  This package uses a grammar of graphics to control various aspects of a plot, and makes it easy to customize how your data is presented.  See the <em>ggplot2</em> book\cite{Wickham} for more details.

In this section, we'll explore how to use Monocle to find genes that are differentially expressed according to several different criteria. First, we'll look at how to use our previous classification of the cells by type to find genes that distinguish fibroblasts and myoblasts. Second, we'll look at how to find genes that are differentially expressed as a function of pseudotime, such as those that become activated or repressed during differentiation.  Finally, you'll see how to perform multi-factorial differential analysis, which can help subtract the effects of confounding variables in your experiment.

To keep the vignette simple and fast, we'll be working with small sets of genes. Rest assured, however, that Monocle can analyze many thousands of genes even in large experiments, making it useful for discovering dynamically regulated genes during the biological process you're studying.

<h3> Finding Genes that Distinguish Cell Type or State </h3>

During a dynamic biological process such as differentiation, cells might assume distinct intermediate or final states.  Recall that earlier we distinguished myoblasts from contaminating fibroblasts on the basis of several key markers. Let's look at several other genes that should distinguish between fibroblasts and myoblasts.
{%highlight R%}
to_be_tested <- row.names(subset(fData(HSMM),
                                 gene_short_name %in% c("UBC", "NCAM1", "ANPEP")))
cds_subset <- HSMM[to_be_tested,]
{%endhighlight%}

To test the effects of <i>CellType</i> on gene expression, we simply call <code>differentialGeneTest</code> on the genes we've selected.
However, we have to specify a <em>model formula</em> in the call to tell Monocle that we care about genes with expression levels that depends on <em>CellType</em>.
Monocle's differential expression analysis works essentially by fitting two models to the expression values for each gene, working through each gene independently.
The first of the two models is called the <em>full</em> model.
This model is essentially a way of predicting the expression value of each gene in a given cell knowing only whether that cell is a fibroblast or a myoblast.
The second model, called the <em>reduced</em> model, does the same thing, but it doesn't know the <em>CellType</em> for each cell.
It has to come up with a reasonable prediction of the expression value for the gene that will be used for <em>all</em> the cells.
Because the full model has more information about each cell, it will do a better job of predicting the expression of the gene in each cell.
The question Monocle must answer for each gene is <em>how much better</em> the full model's prediction is than the reduced model's.
The greater the improvement that comes from knowing the <em>CellType</em> of each cell, the more significant the differential expression result.
This is a common strategy in differential analysis, and we leave a detailed statistical exposition of such methods to others.

To set up the test based on <em>CellType</em>, we simply call <code>differentialGeneTest</code> with a string specifying <em>fullModelFormulaStr</em>.  We don't have to specify the reduced model in this case, because the default of <em>~1</em> is what we want here.

{% highlight R %}
diff_test_res <- differentialGeneTest(cds_subset, fullModelFormulaStr="~CellType")
diff_test_res[,c("gene_short_name", "pval", "qval")]
{% endhighlight %}

Note that all the genes are significantly differentially expressed as a function of <em>CellType</em> except the housekeeping gene TBP, which we're using a negative control.
However, we don't know which genes correspond to myoblast-specific genes (those more highly expressed in myoblasts versus fibroblast specific genes.  We can again plot them with a jitter plot to see:

{%highlight R%}
plot_genes_jitter(cds_subset, grouping="CellType", color_by="CellType",
                  nrow=1, ncol=NULL, plot_trend=TRUE)
{%endhighlight%}

Note that we could also simply compute summary statistics such as mean or median expression level on a per-<em>CellType</em> basis to see this, which might be handy if we are looking at more than a handful of genes.
Of course, we could test for genes that change as a function of <em>Hours</em> to find time-varying genes, or <em>Media</em> to identify genes that are responsive to the serum switch.
In general, model formulae can contain terms in the pData table of the CellDataSet.

The <code>differentialGeneTest</code> function is actually quite simple "under the hood".  The call above is equivalent to:
{% highlight R %}
full_model_fits <- fitModel(cds_subset,  modelFormulaStr="~CellType")
reduced_model_fits <- fitModel(cds_subset, modelFormulaStr="~1")
diff_test_res <- compareModels(full_model_fits, reduced_model_fits)
diff_test_res
{% endhighlight %}

Occassionally, as we'll see later, it's useful to be able to call <code>fitModel</code> directly.

The differential analysis procedure in Monocle is extremely flexible: the model formulae you use in your tests can include any term that exists as a column in the <code>pData</code> table, including those columns that are added by Monocle in other analysis steps. For example, if you use <code>clusterCells</code>, you can test for genes that differ between clusters by using <em>Cluster</em> as your model formula.

<h3> Finding Genes that Change as a Function of Pseudotime </h3>
Monocle's main job is to put cells in order of progress through a biological process (such as cell differentiation) without knowing which genes to look at ahead of time.
Once it's done so, you can analyze the cells to find genes that changes as the cells make progress.
For example, you can find genes that are significantly upregulated as the cells "mature".  Let's look at a panel of genes important for myogenesis:

Monocle's main job is to put cells in order of progress through a biological process (such as cell differentiation) without knowing which genes to look at ahead of time.
Once it's done so, you can analyze the cells to find genes that changes as the cells make progress.
For example, you can find genes that are significantly upregulated as the cells "mature".  Let's look at a panel of genes important for myogenesis:

{% highlight R %}
to_be_tested <- row.names(subset(fData(HSMM),
                                 gene_short_name %in% c("MYH3", "MEF2C", "CCNB2", "TNNT1")))
cds_subset <- HSMM_myo[to_be_tested,]
{% endhighlight %}

Again, we'll need to specify the model we want to use for differential analysis.  This model will be a bit more complicated than the one we used to look at the differences between <em>CellType</em>.  Monocle assigns each cell a "pseudotime" value, which records its progress through the process in the experiment.  The model can test against changes as a function of this value. Monocle uses the <em>VGAM</em> package to model a gene's expression level as a smooth, nonlinear function of pseudotime:

</div>
</div>
</div>

{% include footer.html %}

</body>

</html>
