---
layout: vanilla
permalink: /monocle3/
description: "Documentation for Monocle."
modified: 2013-09-11
tags: [monocle, manual, vignette]
---
<!DOCTYPE html>
<html lang= "{{ page.lang | default: site.lang | default: "en" }}">

  {% include head.html %}

  <!-- See here for how to use the TOC control:
  https://afeld.github.io/bootstrap-toc/ -->
  <body  data-spy= "scroll" data-target= "#toc">
    {% include header.html %}

    <div class= "container">
      <div class= "row">
        <!-- sidebar, which will move to the top on a small screen -->
        <div class= "col-sm-4">
          <nav id= "toc" data-spy= "affix" data-toggle= "toc"></nav>
        </div>
        <!-- main content area -->
        <div class= "col-sm-8">


          <h2>Abstract</h2>

          <h2>Introduction</h2>

          <h2> Installing Monocle </h2>

          <h3> Required software </h3>

          <p>Monocle runs in the <a href= "http://www.r-project.org/">R statistical
          computing environment</a>. You will need R version 3.5 or higher, Bioconductor
          version 3.7, and monocle 2.99.0 or higher to have access to the latest features.
          To install <a href= "http://bioconductor.org/install/">Bioconductor</a>:

{% highlight R %}
source("http://bioconductor.org/biocLite.R")
biocLite()
{% endhighlight %}

          <p>Once you've installed Bioconductor, make sure you've installed Monocle 2 and all
          of its required dependencies:

{% highlight R %}
> biocLite("monocle")
{% endhighlight %}

          <p> Install DDRTree (simple-ppt-like branch) from our GitHub repo:</p>

{% highlight R %}
> devtools::install_github("cole-trapnell-lab/DDRTree", ref="simple-ppt-like")
{% endhighlight %}

          <p> Install the latest version of L1-graph from our GitHub repo:</p>

{% highlight R %}
> devtools::install_github("cole-trapnell-lab/L1-graph")
{% endhighlight %}

          <p> Then pull the monocle3_beta_release branch of the Monocle GitHub repo:</p>

{% highlight R %}
> devtools::install_github("cole-trapnell-lab/monocle-release", ref="monocle3_beta_release")
{% endhighlight %}

          <h3> Testing the installation </h3>

          <p>To ensure that Monocle was installed correctly, start a new R session and type:

{% highlight R %}
library(monocle)
{% endhighlight %}

          <p>Sometimes we add features that require you install certain additional packages.
          You may see errors when you try the above command. You can install the packages
          in the error message by typing (for example):

{% highlight R %}
biocLite(c("DDRTree", "pheatmap"))
{% endhighlight %}

          <h2> Getting help </h2>

          <p>Questions about Monocle 3 should be posted on our <a
          href= "https://groups.google.com/forum/#!forum/monocle-users">Google Group</a>.
          Please use <a href= "mailto:monocle.users@gmail.com">monocle.users@gmail.com</a>
          for private communications that cannot be addressed by the Monocle user
          community. Please do not email technical questions to Monocle contributors
          directly.

          <h2>The Monocle 3 workflow</h2>

          <div class= "text-center">
                <img src= "{{site.baseurl}}/images/monocle3_vignette/workflow.png" width= 500>
          </div>

          Before we get into the details of ordering cells along a trajectory, it's
          important to understand what Monocle is doing. The ordering workflow has three
          main steps, each of which involve a significant machine learning task.

          <h4>Step 1: Normalizing and pre-processing the data </h4>
          <p>To analyze a single-cell dataset, Monocle first normalizes expression values to account for technical variation in RNA recovery and sequencing depth. 
              
          <h4>Step 2: Reducing the dimensionality of the data </h4>
          <p>Next, to eliminate noise and make downstream computations more tractable, it projects each cell onto the top 50 (by default) principal components. Then, you as the user choose whether to reduce the dimensionality further using one of two non-linear methods for dimensionality reduction: t-SNE or UMAP. The former is an extremely popular and widely accepted technique for visualizing single-cell RNA-seq data. The latter is faster, and often better preserves the global structure of the data but is also newer and therefore less well tested by the single-cell community. Then, Monocle 3 will cluster your cells, organize them into trajectories, or both.</p>

          <h4>Step 3: Partitioning the cells </h4>
          <p>Monocle 3 can learn multiple disconnected or "disjoint" trajectories. This is important because many experiments will capture a community of cells that are responding to a stimulus or undergoing differentiation, with each type of cell responding differently. Where Monocle 2 would incorrectly force them all into a single trajectory, Monocle 3 can detect that some cells are part of a different process than others in the dataset. Monocle 3 achieves this by "partitioning" the cells into "supergroups" using a method derived from "approximate graph abstraction" (AGA) (Wolf et al, 2017). Cells from different supergroups cannot be part of the same trajectory.

          <h4>Step 4: Learning the principal graph </h4>
          <p>Monocle 3 provides three different ways to organize cells into trajectories, all of which are based on the concept of "principal graph embedding". DDRTree is the method used in Monocle 2 to learn tree-like trajectories, and has received some important updates in Monocle 3. SimplePPT works similarly to DDRTree in that it learns a tree-like trajectory, but it does not attempt to further reduce the dimensionality of the data. L1Graph is an advanced optimization method that can learn trajectories that have loops in them (that is, trajectories that aren't trees).

          <h4>Step 5: Visualize results </h4>
          <p>Once this is complete, you can run tests for genes that are specific to each cluster, find genes that vary over the course of a trajectory, and plot your data in many different ways. Monocle 3 provides a suite of regression tests to find genes that differ between clusters and over trajectories. Monocle 3 also introduces a new test that uses the principal graph directly and can help find genes that vary in complex ways over a trajectory with loops and more intricate structures.

          <h3>Recommended analysis protocol</h3>
          <p>Monocle is a powerful toolkit for analyzing single-cell RNA-seq.  You don't need
          to use all of its features for every analysis, and there are more than one way
          to do some steps. The workflow is broken up into broad steps. When there's more than
          one way to do a certain step, we've labeled the options as follows:

          <table class= "table">
          <!-- <thead>
          <tr>
          <th>Family function</th>
          <th>Data type</th>
          <th>Notes</th>
          </tr>
          </thead> -->
          <tbody>
          <tr>
          <td><span class= "label label-danger">Required</span></td>
          <td>You need to do this.</td>
          </tr>
          <tr>
          <td><span class= "label label-info">Recommended</span> </td>
          <td>Of the ways you could do this, we recommend you try this one first.</td>
          </tr>
          <tr>
          <td><span class= "label label-success">Alternative</span></td>
          <td>Of the ways you could do this, this way might work better than the one we usually recommend.</td>
          </tr>
          </tbody>
          </table>

          <h3>Monocle 3 steps at a glance</h3>
          <p>Below, you can see snippets of code that highlight the main steps of Monocle.
          Click on the section headers to jump to the detailed sections describing each one. </p>

          <h4><a href= "{{ site.baseurl }}/docs/#getting-started-with-monocle">Store Data in a <a href = "https://rdrr.io/bioc/monocle/man/CellDataSet.html">CellDataSet</a> Object</a></h4>
          The first step in working with Monocle is to load up your data into Monocle's
          main class, <code><a href = "https://rdrr.io/bioc/monocle/man/CellDataSet.html">CellDataSet</a></code>:

{% highlight R %}
pd <- new("AnnotatedDataFrame", data = sample_sheet)
fd <- new("AnnotatedDataFrame", data = gene_annotation)
cds <- newCellDataSet(expr_matrix, phenoData = pd, featureData = fd)
{% endhighlight %}

          <h4><a href= "{{ site.baseurl }}/docs/#classifying-and-counting-cells">Classify cells with known marker genes</a></h4>
          Next, leverage your knowledge of key marker genes to quickly and easily classify your cells by type:
{% highlight R %}
cth <- newCellTypeHierarchy()

MYF5_id <- row.names(subset(fData(cds), gene_short_name == "MYF5"))
ANPEP_id <- row.names(subset(fData(cds), gene_short_name == "ANPEP"))

cth <- addCellType(cth, "Myoblast", classify_func =
    function(x) { x[MYF5_id,] >= 1 })
cth <- addCellType(cth, "Fibroblast", classify_func =
    function(x) { x[MYF5_id,] < 1 & x[ANPEP_id,] > 1 } )

cds <- classifyCells(cds, cth, 0.1)
{% endhighlight %}

          <h4><a href= "{{ site.baseurl }}/docs/#clustering-cells">Cluster your cells</a></h4>
          You can easily cluster your cells to find new types:

{% highlight R %}
cds <- clusterCells(cds)
{% endhighlight %}

          <h4><a href= "{{ site.baseurl }}/docs/#constructing-single-cell-trajectories">Order cells in pseudotime along a trajectory</a></h4>
          Now, put your cells in order by how much progress they've made through whatever process you're studying, such as differentiation,
          reprogramming, or an immune response.

{% highlight R %}
disp_table <- dispersionTable(cds)
ordering_genes <- subset(disp_table, mean_expression >= 0.1)
cds <- setOrderingFilter(cds, ordering_genes)
cds <- reduceDimension(cds)
cds <- orderCells(cds)
{% endhighlight %}

          <h4><a href= "{{ site.baseurl }}/docs/#differential-expression-analysis">Perform differential expression analysis</a></h4>
          Compare groups of cells in myriad ways to find differentially expressed genes,
          controlling for batch effects and treatments as you like:

{% highlight R %}
diff_test_res <- differentialGeneTest(cds,
    fullModelFormulaStr = "~Media")
sig_genes <- subset(diff_test_res, qval < 0.1)
{% endhighlight %}










        <h2>Tutorial: learning trajectories with Monocle 3</h2>
            <p> In this tutorial, we demonstrate how to use Monocle 3 (alpha release) to resolve multiple disjoint trajectories. We will mainly introduce:</p>
            <ul>
            <li>How to learn tree-like trajectories with monocle 3 in two or three dimensions.</li>
            <li>How to choose the starting point(s) for the trajectory.</li>
            <li>How to visualize these trajectories in static 2D plots and interactive 3D plots.</li>
            </ul>
          
            <h3 data-toc-text= "Step 1: Load Monocle">Trajectory step 1: Load Monocle </h3>
{% highlight R %}
rm(list = ls())  # Clear the environment 
options(warn=-1) # Turn off warning message globally 
library(monocle) # Load Monocle
{% endhighlight %}


          <h3 data-toc-text= "Step 2: Load data">Trajectory step 2: Load the data </h3>

          <p>Let's load up the data from Paul et. al, which explored hematopoeisis at single-cell resolution. To save time, we'll just load a CellDataSet object. We'll also change the cluster IDs from the original study into easier to read names. Then we'll set up some colors for each of them that we'll use in some plots later. 
              
          <p>Monocle 3 makes some changes to the CellDataSet class, so we'll call a function to "upgrade" the old object to the new format. Finally, we'll adjust one of the factor levels to make the cell types easier to read.


{% highlight R %}
cds <- readRDS('data/valid_subset_GSE72857_cds2.RDS')
pData(cds)$cell_type2 <- plyr::revalue(as.character(pData(cds)$cluster), 
                                        c("1" = 'Erythrocyte', 
                                        "2" = 'Erythrocyte', 
                                        "3" = 'Erythrocyte', 
                                        "4" = 'Erythrocyte', 
                                        "5" = 'Erythrocyte', 
                                        "6" = 'Erythrocyte', 
                                        "7" = 'Multipotent progenitors', 
                                        "8" = 'Megakaryocytes', 
                                        "9" = 'GMP', 
                                        "10" = 'GMP',
                                        "11" = 'Dendritic cells', 
                                        "12" = 'Basophils', 
                                        "13" = 'Basophils', 
                                        "14" = 'Monocytes', 
                                        "15" = 'Monocytes', 
                                        "16" = 'Neutrophils', 
                                        "17" = 'Neutrophils', 
                                        "18" = 'Eosinophls', 
                                        "19" = 'lymphoid'))

cell_type_color <- c("Basophils" = "#E088B8", 
                    "Dendritic cells" = "#46C7EF", 
                    "Eosinophls" = "#EFAD1E", 
                    "Erythrocyte" = "#8CB3DF", 
                    "Monocytes" = "#53C0AD", 
                    "Multipotent progenitors" = "#4EB859", 
                    "GMP" = "#D097C4", 
                    "Megakaryocytes" = "#ACC436", 
                    "Neutrophils" = "#F5918A", 
                    'NA' = '#000080')

# Update the old CDS object to be compatible with Monocle 3                    
cds <- updateCDS(cds) 
{% endhighlight %}

          <br>

          <h3 data-toc-text= "Step 3: Order cells">Trajectory step 3: Estimate size factors and dispersions </h3>

          <p>We then estimate size factors for each cell and dispersion function for the genes in the cds as usual. Monocle 3 now performs these operations using the DelayedArray packages so they work on datasets with millions of cells.

{% highlight R %}
cds <- estimateSizeFactors(cds)
cds <- estimateDispersions(cds)
{% endhighlight %}

          <br>

          <h3 data-toc-text= "Step 4: Preprocess data">Trajectory step 4: Pre-process the data </h3>

          <p> Next, run the <code>preprocessCDS()</code> function to project the data onto the top principal components: </p>

{% highlight R %}
cds <- preprocessCDS(cds, num_dim = 20)
{% endhighlight %}

          <br>

          <h3 data-toc-text= "Step 5: Reduce dimensionality">Trajectory step 5: Reduce the dimensionality of the data </h3>

          <p> Then, apply a further round of (nonlinear) dimensionality reduction using UMAP: </p>
         
{% highlight R %}
cds <- reduceDimension(cds, reduction_method = 'UMAP')
{% endhighlight %}
         
          <br>

          <p>Now we're ready to start learning trajectories!</p>

          <br>

          <h3 data-toc-text= "Step 6: Partition cells">Trajectory step 6: Partition the cells into supergroups </h3>
          
          <p>Rather than forcing all cells into a single developmental trajectory, Monocle 3 enables you to learn a set of trajectories that describe the biological process you're studying. For example, if you're looking at a community of immune cells responding to infection, each cell type will respond to antigen (and each other) in a different way, so they should be organized into distinct trajectories.</p>

          <p>In Monocle 3, we recognize "disjoint" trajectories by drawing on ideas from Alex Wolf and colleagues, who recently introduced the concept of abstract graph participation. Monocle 3 implements the test for cell community connectedness from Wolf et al via the partitionCells() function, which divides the cells into "supergroups".</p>

{% highlight R %}
cds <- partitionCells(cds)
{% endhighlight %}

          <h3 data-toc-text= "Step 7: Learn graph">Trajectory step 7: Learn the principal graph </h3>
          
          <p>Now that the cells are paritioned, we can organize each supergroup into a separate trajectory. The default method for doing this in Monocle 3 is SimplePPT, which assumes that each trajectory is a tree (albeit one that may have multiple roots). Learn these trees with the learnGraph function:</p>


{% highlight R %}
cds <- learnGraph(cds,  RGE_method = 'SimplePPT')
plot_cell_trajectory(cds, color_by = "cell_type2") + scale_color_manual(values = cell_type_color)
{% endhighlight %}

          <div class= "text-center">
                <img src= "{{site.baseurl}}/images/monocle3_vignette/paul_simpleppt_2d_color_by_type.png" width= 600>
                </div>
      
          <p>You can see that Monocle has learned two trajectories, one of which is tiny and essentially trivial. The other has one major branch. SimplePPT essentially is finding a principal graph that fits nicely within the cells as projected in the UMAP coordinate space.</p>
          
          <h3 data-toc-text= "Step 8: Define start points">Trajectory step 8: Define the starting point(s) for the trajectory </h3>
          
          <p>In the trajectory above, you can see that the "Multipotent progenitor" cells are located roughly in the middle of the longer trajectory segment. We know from extensive past study of hematopoeisis that these are the "root" cell state that generates all the others in the primary trajectory. We need to tell Monocle that these cells are the "beginning" of the trajectory. In Monocle 2, this wouldn't be possible, because the software required that the root be one of the leaves of the tree. Monocle 3 allows you to specify an internal part of the tree as the root. There are two ways to do this:</p>

          <ol>
              <li>You can specifiy the name of a specific cell or principal graph node as the root by passing it to <code>orderCells()</code>.</li>
              <li>You can call <code>orderCells()</code> with no root specified and it will open a window for you to select the root(s) with your mouse cursor. This latter option is only available in interactive sessions, and doesn't work in Jupyter notebooks.</li>
          </ol>

          <p>Once you select one or more roots, <code>orderCells()</code> computes the shortest path from each cell's location on the princiapl graph to the nearest root node. That is, a cell's pseudotime value is the geodesic distance from it to the nearest root, traveling over the graph. Any cell that is not reachable from some root will be assigned a pseudotime value of infinity.</p>

          <p>You may find it helpful to automatically pick the root according to any number of biologically-driven criteria. For example, you could find the nodes at which cells expressing a certain marker gene are concentrated. Or could select the node where cells from an early experimental timepoint land. Here, we provide one such helper function to show you how to do this kind of thing:</p>


{% highlight R %}
# a helper function to identify the root principal points: 
get_correct_root_state <- function(cds, cell_phenotype, root_type){
  cell_ids <- which(pData(cds)[, cell_phenotype] == root_type)

  closest_vertex <- cds@auxOrderingData[[cds@dim_reduce_type]]$pr_graph_cell_proj_closest_vertex
  closest_vertex <- as.matrix(closest_vertex[colnames(cds), ])  
  root_pr_nodes <- V(cds@minSpanningTree)$name[as.numeric(names(which.max(table(closest_vertex[cell_ids,]))))]
    
  root_pr_nodes
}
{% endhighlight %}

          <p>In the above function, we are accessing <code>pr_graph_cell_proj_closest_vertex</code> which is just a list that stores for each cell, the ID of the principal graph node it's closest to. This is handy for computing statistics (e.g. with dplyr) about the principal graph nodes and which cells of what type map to them.
          
          <p>Now we can call this function to automatically find the node in the principal graph where our multipotent progenitors reside:</p>
          
{% highlight R %}
MPP_node_ids = get_correct_root_state(cds, cell_phenotype = 'cell_type2', "Multipotent progenitors")
cds <- orderCells(cds, root_pr_nodes = MPP_node_ids)
plot_cell_trajectory(cds) 
{% endhighlight %}


<div class= "text-center">
        <img src= "{{site.baseurl}}/images/monocle3_vignette/paul_simpleppt_2d_color_by_pseudotime.png" width= 600>
        </div>

        <h3 data-toc-text= "3D trajectories">Learning and visualizing trajectories in 3D </h3>

        <p>Sometimes, projecting cells into three dimensions instead of two can make the biological process you're studying easier to interpret. In Monocle 3, we provide the plot_3d_cell_trajectory function to plot a dataset in 3 dimensions. The block of code below shows you how to learn a trajectory in 3D. Similarly to the 2d case, it:</p>

        <ol>
            <li>Reduces the data down into three dimensions using UMAP</li>
            <li>Learns and the trajectory trajectory and orders the cells</li>
            <li>Visualizes the 3D trajectory</li>
        </ol>

          
{% highlight R %}
cds <- reduceDimension(cds, max_components = 3,   
                       reduction_method = 'UMAP',
                       metric="correlation", 
                       verbose = F)

cds <- learnGraph(cds, max_components = 3, RGE_method = 'SimplePPT', partition_component = T, 
                  verbose = F)

cds <- orderCells(cds, 
                  root_pr_nodes = get_correct_root_state(cds, 
                                                         cell_phenotype = 'cell_type2', 
                                                         "Multipotent progenitors"))
                     
plot_3d_cell_trajectory(cds, 
                        color_by="cell_type2", 
                        webGL_filename=paste(getwd(), "/trajectory_3D.html", sep=""), 
                        palette=detailed_cell_type_color,
                        show_backbone=TRUE, 
                        useNULL_GLdev=TRUE)
{% endhighlight %}


{% include widget_scripts/valid_subset_GSE72857_cds2.html %}

        
          <h2>Citation </h2>


          If you use Monocle to analyze your experiments, please cite:

{% highlight R %}

citation("monocle")

##   Cole Trapnell and Davide Cacchiarelli et al (2014): The dynamics
##   and regulators of cell fate decisions are revealed by
##   pseudo-temporal ordering of single cells. Nature Biotechnology
##
##   Xiaojie Qiu, Andrew Hill, Cole Trapnell et al (2017):
##   Single-cell mRNA quantification and differential analysis with
##   Census. Nature Methods
##
##   Xiaojie Qiu, Cole Trapnell et al (2017): Reverse graph embedding
##   resolves complex single-cell developmental trajectories. BioRxiv
##
##   To see these entries in BibTeX format, use 'print(<citation>,
##   bibtex=TRUE)', 'toBibtex(.)', or set
##   'options(citation.bibtex.max= 999)'.

{% endhighlight %}


          <h2>Acknowledgements </h2>

          Monocle was originally built by Cole Trapnell and Davide Cacchiarelli, with substantial design input John Rinn and Tarjei Mikkelsen. We are grateful to Sharif Bordbar, Chris Zhu, Amy Wagers and the Broad RNAi platform for technical assistance, and Magali Soumillon for helpful discussions. Cole Trapnell is a Damon Runyon Postdoctoral Fellow. Davide Cacchiarelli is a Human Frontier Science Program Fellow. Cacchiarelli and Mikkelsen were supported by the Harvard Stem Cell Institute. John Rinn is the Alvin and Esta Star Associate Professor. This work was supported by NIH grants 1DP2OD00667, P01GM099117, and P50HG006193-01. This work was also supported in part by the Single Cell Genomics initiative, a collaboration between the Broad Institute and Fluidigm Inc.

          Monocle 2 was developed by Cole Trapnell's lab. Significant portions were written by Xiaojie Qiu. The work was supported by NIH grant 1DP2HD088158 as well as an Alfred P. Sloan Foundation Research Fellowship.

          This vignette was created from Wolfgang Huber's Bioconductor vignette style document, and patterned after the vignette for <em>DESeq</em>, by Simon Anders and Wolfgang Huber.

          <h2>References </h2>


          <p> [1] Cole Trapnell, Davide Cacchiarelli, Jonna Grimsby, Prapti Pokharel, Shuqiang Li, Michael Morse, Niall J. Lennon, Kenneth J. Livak, Tarjei S. Mikkelsen, and John L. Rinn. <a href = "http://www.nature.com/nbt/journal/v32/n4/abs/nbt.2859.html"> The dynamics and regulators of cell fate decisions are revealed by pseudotemporal ordering of single cells</a>. Nature Biotechnology, 2014. </p>

          <p> [2] Cole Trapnell, Adam Roberts, Loyal Goff, Geo Pertea, Daehwan Kim, David R Kelley, Harold Pimentel, Steven L Salzberg, John L Rinn, and Lior Pachter. <a href = "https://www.ncbi.nlm.nih.gov/pubmed/22383036"> Differential gene and transcript expression analysis of RNA-seq experiments with TopHat and Cufflinks</a>. Nature Protocols, 7(3):562–578, March 2012. </p>

          <p> [3] Laurens van der Maaten and Geoffrey Hinton. <a href = "http://www.jmlr.org/papers/volume9/vandermaaten08a/vandermaaten08a.pdf"> Visualizing data using t-SNE</a>. J. Mach. Learn. Res., 9(Nov):2579– 2605, 2008. </p>

          <p> [4] Alex Rodriguez. Alessandro Laio. <a href = "http://science.sciencemag.org/content/344/6191/1492"> Clustering by fast search and find of density peaks</a>. Science, 344:1492–1496, 2014. </p>

          <p> [5] Hadley Wickham. <a href = "http://www.springer.com/us/book/9780387981413"> ggplot2: Elegant Graphics for Data Analysis</a>. Springer-Verlag New York, 2009. </p>

          <p> [6] Simon Anders and Wolfgang Huber. <a href = "https://genomebiology.biomedcentral.com/articles/10.1186/gb-2010-11-10-r106"> Differential expression analysis for sequence count data</a>. Genome Biol., 11(10):R106, 2010. </p>

          <p> [7] Qi Mao, Li Wang, Steve Goodison, and Yijun Sun. <a href= "http://dl.acm.org/citation.cfm?id= 2783309"> Dimensionality reduction via graph structure learning</a>. In Proceedings of the 21th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, pages 765–774. ACM, 2015. </p>

          <p> [8] X Qiu, A Hill, J Packer, D Lin, YA Ma, and C Trapnell. <a href= "https://www.ncbi.nlm.nih.gov/pubmed/28114287"> Single-cell mrna quantification and differential analysis with census</a>. Nature methods, 2017. </p>

          <p> [9] Rahul Satija, Jeffrey A Farrell, David Gennert, Alexander F Schier, and Aviv Regev. <a href= "https://www.ncbi.nlm.nih.gov/pubmed/25867923"> Spatial reconstruction of single-cell gene expression data</a>. Nat. Biotechnol., 33(5):495–502, May 2015. </p>

          <p> [10] Xiaojie Qiu, Qi Mao, Ying Tang, Li Wang, Raghav Chawla, Hannah Pliner, and Cole Trapnell. <a href= "http://www.biorxiv.org/content/early/2017/02/21/110668"> Reversed graph embedding resolves complex single-cell developmental trajectories</a>. 21 February 2017. </p>

          <p> [11] Evan Z Macosko, Anindita Basu, Rahul Satija, James Nemesh, Karthik Shekhar, Melissa Goldman, Itay Tirosh, Allison R Bialas, Nolan Kamitaki, Emily M Martersteck, John J Trombetta, David A Weitz, Joshua R Sanes, Alex K Shalek, Aviv Regev, and Steven A McCarroll. <a href= "https://www.ncbi.nlm.nih.gov/pubmed/26000488">Highly parallel genome-wide expression profiling of individual cells using nanoliter droplets</a>. Cell, 161(5):1202–1214, 2015. </p>

          <p> [12] Qi Mao, Li Wang, Ivor Tsang, and Yijun Sun. <a href= "http://ieeexplore.ieee.org/document/7769209/?reload=true">Principal graph and structure learning based on reversed graph embedding </a>. IEEE Trans. Pattern Anal. Mach. Intell., 5 December 2016. </p>

          <p> [13] Cabili, Moran N. et al. <a href = "https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3185964/">Integrative Annotation of Human Large Intergenic Noncoding RNAs Reveals Global Properties and Specific Subclasses</a>. Genes & Development 25.18 (2011): 1915–1927. PMC. Web. 21 June 2017. </p>


</div>
</div>
</div>

<br>
<br>
<br>
<br>
<br>
<br>

{% include footer.html %}

</body>

</html>
